<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Zeva`s Space</title>
        <link>https://ZevaXu.github.io/posts/</link>
        <description>All Posts | Zeva`s Space</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 02 Dec 2021 10:22:37 &#43;0800</lastBuildDate><atom:link href="https://ZevaXu.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Go语言基础—3.基础数据类型</title>
    <link>https://ZevaXu.github.io/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
    <pubDate>Thu, 02 Dec 2021 10:22:37 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://ZevaXu.github.io/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
    <description><![CDATA[3 基础数据类型 虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。进一步将这些数组织在一起，就可表达更多的对象。
Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
3.1 整型 基础类型
有符号：
int8、int16、int32、int64四种
无符号：
uint8、uint16、uint32、uint64四种
rune：对应int32，表示一个Unicode码点。这两个名称可以互换使用
byte：是uint8类型的等价类型，强调数值是一个原始的数据而不是一个小的整数。
int：32位操作系统—int32、64位操作系统—int64
uintptr:一种无符号的整数类型,没有指定具体的bit大小但是足以容纳指针.
类型转换
算术和逻辑运算的二元操作中必须是相同的类型，所以int32和int64不能直接相加减。
显示类型转换：
1  var compote = int(apples) + int(oranges)   对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度。
浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。
3.2 浮点数 Go语言提供了两种精度的浮点数，float32和float64。
float32
1.4e-45～3.4e38；
精度到6个十进制位
float64:
4.9e-324～1.8e308
精度到15个十进制位
3.3 复数 Go语言提供了两种精度的复数类型：complex64和complex128。
内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：
1 2 3 4 5 6 7 8 9 10  var x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.]]></description>
</item><item>
    <title>Go语言基础—2.程序结构</title>
    <link>https://ZevaXu.github.io/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</link>
    <pubDate>Wed, 01 Dec 2021 10:14:04 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://ZevaXu.github.io/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</guid>
    <description><![CDATA[2.1 命名 命名规则：
  字母和下划线开头，后可以接任何数量的字母、数字或下划线（区分大小写）。
  不能使用go关键字来命名。
  不推荐使用go预定义名字命名。
  习惯用驼峰命名法。
  可见性：
  在函数内定义，仅函数可用。
  在函数外定义，包级可用。
  循环体的变量仅循环内可用。
  名字开头的大小写决定了是否是导出型（外部是否可以访问）
fmt.Printf()
  2.2 声明 声明语句定义了程序的各种实体对象以及部分或全部的属性。主要有4种类型的声明语句：
  var：变量
  const：常量
  type：类型
  func：函数
  2.3 变量 声明变量的一般语法：
1  var 变量名 类型 = 表达式   其中，类型和= 表达式两者可省略其一。编译器会自动推断变量的类型或者初始值。
各个类型的0值：
  整型类型0值为0
  布尔类型为false]]></description>
</item><item>
    <title>计算机网络：链路层和局域网</title>
    <link>https://ZevaXu.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</link>
    <pubDate>Tue, 23 Nov 2021 13:29:32 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://ZevaXu.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</guid>
    <description><![CDATA[链路层和局域网 6.1 链路层概述 在本章中，将运行链路层协议的任何设备称为节点，节点包括主机、路由器、交换机和wifi接入点。把沿着通信路径连接相邻的通信信道称为链路。
该数据报将实际通过6段链路：发送主机与WiFi接入点之间的WiFi链路，接入点和链路层交换机之间的以太网链路，链路层交换机与路由器之间的链路，两台路由器之间的链路，最后是交换机和服务器之间的以太网链路。在通过特定的链路时，传 输节点将数据报封装在链路层帧中，并将该帧传送到链路中。
注意到这3段运输是由不同的公司管理，使用了完全不同的运输方式（豪华大轿车、飞机和火车）。尽管运输方式不同，但它们都提供了将旅客从一个地点运输到相邻地点的基本服务。在这个运输类比中，一个游客好比一个数据报，每个运输区段好比一条链路，每种运输方式好比一种链路层协议，而该旅行社好比一个路由选择协议。
6.1.1 链路层提供的服务 6.4 交换局域网 6.4.1 链路层寻址和ARP 交换机运行在链路层，它们交换链路层帧，不识别网络层地址。
网络层和链路层都需要地址。
1. MAC地址 并不是主机或路由器具有链路层地址，是它们的适配器（网卡、网络接口）具有链路层地址。
MAC地址（LAN 地址、物理地址），长度为6字节，被设定为永久的（但是软件可以改变）。
IEEE管理着MAC地址的分配，网卡厂商生产网卡时，IEEE固定一个MAC地址的前24比特，后面毕业由厂商自己分配。
无论机器在何方，MAC地址总是不会变，不像IP地址具有层次结构，在不同的局域网，IP地址会改变。（MAC地址像身份证号，IP地址像邮政编码）
当某些适配器要向另一目的适配器发送一个帧，源适配器将包含目的适配器MAC地址插入到该帧中，发送到局域网。适配器接收到帧，与自己的MAC地址匹配，匹配上则接收，不匹配则丢弃。
当适配器想让局域网内所有适配器都接收一个帧，就插入一个特殊的MAC广播地址（48个1，FF- FF- FF- FF- FF- FF）
为什么既要MAC地址，又要IP地址？
IP地址工作在网络层，MAC地址工作在链路层。
局域网是为了任意网络层协议而设计的，不仅仅是IP和HTTP，如果适配器被分配为IP地址，而不是MAC地址，那么将不能方便的支持其他网络层协议。
如果适配器使用网络层地址，而不是MAC地址，那么适配器缓存必须存储IP地址，每次改变都要重新配置。
如果适配器不使用地址，IP数据报向上网络层传递，网络层根据数据报携带的目的地址匹配，那么对于每个帧，主机都将花费时间和资源去处理。
总而言之，不同的层需要它们自己的寻址方案，目前，我们看到有3种类型的地址：应用层的主机名、网络层的IP地址、链路层的MAC地址。
2. 地址解析协议ARP 地址解析协议：完成网络层IP地址和链路层MAC地址的转换，将IP地址解析为MAC地址（DNS将主机名解析为IP地址）。ARP只为在同一个子网上的主机和路由器解析IP地址。
ARP表：
每个主机和路由器在内存中都有一个ARP表，该表包含了IP地址到MAC地址的转换，每条记录都有一个生存时期（一般20分钟），ARP表不一定记录了局域网内所有主机IP和MAC的条目。
当ARP表中没有目的主机对应的MAC地址时：
 源主机向适配器传递一个包含MAC广播地址的ARP查询分组 子网上所有的适配器都能接收该分组，并向上传递给其ARPmo模块 IP地址匹配的适配器会发送一个ARP响应分组 源主机更新其ARP表  查询ARP报文在广播帧中发送，响应ARP报文在标准帧中发送。
ARP表是即插即用的，自动建立，当主机与子网断开，其他主机内存中的ARP表最终也不会保留该主机的记录。
ARP表既包含网络层IP地址，也包含链路层MAC地址，所以该协议是跨链路层和网络层边界的协议。
发送数据报到子网以外 右上角主机A向右下角主机B发送数据。
 A发送的数据报携带B的IP地址和路由器的MAC地址 路由器接收到数据报，更具其ARP表，转发携带B的IP地址和B的MAC地址的数据报  6.4.2 以太网 以太网是到目前为止最流行的有线局域网技术，而且到可能预见的将来它可能仍保持这一位置。
集线器：
工作在物理层，作用于比特而不是帧，当表示一个0或者1的一个比特到达一个接口，集线器重新生出这个比特，并将其能量强度放大，将该比特向其他所有接口传输出去。
因此，集线器下的是一个广播局域网。并且当同时收到两个接口发来的帧时，将发生碰撞，生出该帧的节点必须重传。
1. 以太网帧结构 ​  数据(46~1500字节)：承载IP数据报。MTU（最大传输单元），一般为1500字节，如果IP数据报超过1500，主机必须将数据报分片；最小为46字节，如果小于46字节，数据报必须被填充到46字节（利用IP数据报中长度字节去除填充部分）。 目的地址(6字节)：目的适配器的MAC地址。当目的适配器收到一个以太网帧，当该帧中的目的地址是自身地址或者是广播地址时，该适配器将帧的数据字段内容传给网络层；当收到其他MAC地址的帧，丢弃之。 源地址(6字节)：包含了传输该帧到局域网上的适配器MAC地址。 类型字段(2字段)：指定了数据帧的不同网络层协议。 CRC(4字节)：循环冗余检测，使得接收适配器检测帧是否引入了差错。 前同步码(8字节)：前7个字节用于同步两个适配器的时钟；第8个字节提示重要的内容就要到了。  以太网技术向网络层提供服务的特点：]]></description>
</item><item>
    <title>计算机网络：网络层协议</title>
    <link>https://ZevaXu.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/</link>
    <pubDate>Wed, 17 Nov 2021 13:17:31 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://ZevaXu.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/</guid>
    <description><![CDATA[网络层协议 ​
控制平面作为一种网络范围的逻辑，不仅控制沿着从源主机到目的主机的端到端路径间的路由器如何转发数据报，而且控制网络层组件和服务如何配置和管理。
OSPF是一种运行在单一ISP的网络中的路由选择算法。BGP是一种在因特网中用于 互联所有网络的路由选择算法，因此常被称为因特网的“黏合剂” 。
5.2 路由选择算法 其目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径(等价于路由)。通常，一条好路径指具有最低开销的路径。
分类  根据该算法是集中式还是分散式  集中式路由选择算法：用完整的、全局性的网络知识计算岀从源到目的地之间的最低开销路径。 要求该算法在真正开始计算以前，要以某种方式获得这些信息。 具有全局状态信息的算法常被称作链路状态(Link State, LS) 算法。 分散式路由选择算法：没有节点拥有关于所有网络链路开销的完整信息。 相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后，通过迭 代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或 一组目的节点的最低开销路径。   根据算法是静态的还是动态  在静态路由选择算法(static routing algorithm)：路由随时间的变化非常缓慢，通常是人工进行调整(如人为手工编辑一条链路开销) 。 动态路由选择算法(dynamic routing algorithm) ：随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路开销的变化而运行。   根据它是负载敏感的还是负载迟钝的进行划分  负载敏感算法：链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该 拥塞链路来选择路由。 负载迟钝算法：某条链路的开销不明确反映当前或者最近的拥塞水平。    5.2.2 距离向量路由选择算法 5.3 因特网中自治系统内部的路由选择:OSPF 上述讨论的LS（狄杰斯特拉）和距离向量路由选择协议都不能适用于整个网络，原因有如下两点：
 网络规模。当今的因特网由数亿台主机组成。在这些主机中存储的路由选择信息显然需要巨大容量的内存。并且求出所有路由器之间的链路开销需要巨大的负担，并且距离向量算法可能永远无法收敛。 管理自治。因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器(如在自己的网络中运行它所选择的某种路由选择算法)，或对外部隐藏其网络的内部组织面貌。  自治系统（AS）：一个自治系统由其全局唯一的AS号(ASN)所标识。每个AS由一组通常处在相同管理控制下的路由器组成。 通常在一个ISP中的路由器以及互联它们的链路构成一个AS；也有某些ISP将网络划分为多个AS；也有一个一级ISP在整个网络使用一个庞大的AS，其他子ISP再进行划分为多个AS。
开放最短路优先(OSPF) OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。 使用OSPF, —台路由器构建了一幅关于整个自治系统的完整拓扑图(即一幅图)。于是, 每台路由器在本地运行Dijkstra的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。
各条链路开销是由网络管理员配置，管理员也许会选择将所有链路开销设为1,因而实现了最少跳数路由选择，或者可能会选择将链路权值按与链路容量成反比来设置，从而不鼓励流量使用低带宽链路。
使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时(如开销的变化或连接/中断状态的变化)，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地 (至少每隔30 min一次)广播链路状态 。
优点：
  安全。路由器间的OSPF报文能够配置两类鉴别，即简单的和MD5的。使用简单的鉴别，每台路由器配置相同的口令。当一台路由器发送一个OSPF分组，它以明文方式包括了口令 。MD5的要对比报文携带的MD5散列和路由去计算出来的MD5值。]]></description>
</item><item>
    <title>计算机网络：可靠数据传输协议原理</title>
    <link>https://ZevaXu.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/</link>
    <pubDate>Thu, 04 Nov 2021 12:29:26 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://ZevaXu.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/</guid>
    <description><![CDATA[可靠数据传输协议原理 构造可靠传输协议 可靠数据传输协议是由 检验和、序号、定时器、肯定和否定确认这几个机制来确保的。
其中检验和用于接收方判断分组是否发生错误，序号帮助发送方决定重新发送哪个分组，接收方发送肯定和否定确认告诉发送方是否正确接收到了分组。
将发送方称为S，接收方成为R，考虑以上几种情况：
  一切正常
S向R发送0号分组，R收到了分组，利用检验和判断分组是否正确，如果正确，R向S发送一个0号分组的ACK确认分组，告诉S已经收到了正确分组。S再向R发送下一个分组1。
  分组丢失
S向R发送0号分组，此时S的定时器开始计时，0号分组在传输过程中丢失，R没有收到任何数据，所以也没有向S发送任何确认信号。当计时器停止时，S向R在发送一个0号分组。
  ACK丢失
S向R发送0号分组，并开启了定时器。R收到了分组，并回传一个ACK信号，但是信号在传输过程中丢失，当S的定时器停止时，S会再向R发送相同分组，此时R再次收到了相同的分组，开启冗余检测机制，会丢弃冗余的分组。
  过早超时
S向R发送0号分组，并开启了定时器。R收到了分组，并回传一个ACK信号，但是信号在传输过程中超时，S又发了一个相同的分组给R，之后S收到该上一个分组ACK，但是它什么也不做。
  流水线可靠数据传输协议 如果采取“可靠数据传输协议”：接收一个分组，等待一个ACK到达后，再发送下一个分组的方式，发送发大部分时间都处于等待中，会带来有效吞吐量小，发送方利用率低的缺陷。
引入流水线技术有助于解决这种缺陷。即不以停等的方式运行，允许发送方发送多个分组而无须等待确认。
这样的技术提出如下几个要求：
 增加序号的范围，每个分组必须有一个唯一的序号，有多个再输送中而未被确认的分组 发送方和接收方两端需要缓存多个分组。发送方最低限度要缓存那些已经发送但没有确认的分组。  解决流水线的差错恢复有两种基本方法：回退N步（go-back-N,GBN)、选择重传(Selective Repeat,SR)
GBN(回退N步) 窗口长度N由包括两部分（已发送但未被确认的分组和可用但是还没有发送的分组序号）组成。
一个分组的序号承载在分组首部的一个固定长度字段中规定，例如如果只分配1比特给这个字段，那么这个序号空间只能是0和1。
GBN的运行过程如下图：
发送方批量发送多个分组，并为每个已经发送的分组开启一个定时器，接收方按序接收分组，每接收到一个分组，发送一个ACK。
例如发送方批量发送了0—4号分组，其中3号分组丢失。
对于发送方：它的3号计时器到期后，就把3号及3号之后的分组再重新发送；
对于接收方：它收到了0、1、2号分组，每收到一个就发送该分组的ACK。由于未收到3号分组，它接收到4号分组后，把4号分组丢弃，再发送上一个正确分组的ACK，即2号ACK。直到接收到3号分组为止。
GBN协议允许发送方用多个分组填充流水线，因此避免了停等协议中的信道利用率问题，使用到了序号、累计确认、检验和、超时重传操作等技术。
选择重传 GBN协议也存在一些性能问题，当窗口长度和传输时延过大时，单个分组的差错带来的大量不必要重传的分组再次重传。
选择重传协议通过让接收方缓存没有确认的分组以及维护一个窗口的方式，实现发送方仅仅重传接收方没有收到或者受损的分组。
分组重新排序问题：
分组重新排序的表现：一个具有序号或者确认号x的分组的旧副本可能突然出现。
当信道是一个网络时，分组重新排序是可能发生的，此时，网络相当于缓存了分组，并随时可能把分组释放出来。
解决：
确保一个序号不被重新使用，假定分组在网络中的存活时间最大为3分钟。]]></description>
</item><item>
    <title>计算机网络: 面向连接的传输-TCP</title>
    <link>https://ZevaXu.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/</link>
    <pubDate>Mon, 01 Nov 2021 12:14:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://ZevaXu.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/</guid>
    <description><![CDATA[TCP是因特网运输层的面向连接的可靠的运输协议。依赖于差错检测、重传、累计确认、定时器以及带有序号和确认号的首部字段，使得它可以在不可靠的IP协议之上，提供可靠的运输协议。
3.5.1 TCP连接概述   TCP是面向连接的。这里的连接指的是一两条逻辑连接，其共同状态包括要维护的参数、TCP缓存等,仅仅保留在两个通信端系统的TCP程序中。
  *TCP是点到点的。即单个发送方和单个接收方之间的连接，其中发送方被称为客户端，接收端被称为服务器。
  *建立连接的过程：客户先发送一个特殊（首部字段特殊）的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后客户端再用第三个特殊报文段作为响应，前两个报文段不承载任何应用层数据。这样一个建立连接的过程称为三次握手。
  一旦建立起TCP连接，两个应用进程旧可以相互发送数据。客户进程将数据通过套接字传给TCP，TCP将这些数据存入发送缓存，接下来再陆续从发送缓存里取出数据，封装送给网络层。
  *MSS（Maximum Segment Size,最大报文长度）：报文段里应用层数据的最大长度，不包括首部字段。
  *MTU（Maximum Transmission Unit,最大传输单元）：包含TCP首部的报文段最大长度，以太网和PPP链路层协议都有1500字节的MTU，一个典型值是1460。
  TCP连接的组成：客户端主机上的缓存、变量与套接字；服务器主机上的缓存、变量与套接字。
3.5.2 TCP报文段结构 TCP的首部一般是20字节，比UDP首部多12字节。
 源端口号和目的端口号：用于多路复用/分解 32比特的序号字段/32比特的确认号字段：用于实现可靠数据传输 16比特的接收窗口字段，用于流量控制 4比特首部长度字段：指示了TCP的首部长度 可选与变长的选项字段：用于连接双方协商最大报文长度（MSS） 6比特的标志字段：  ACK：指示确认字段中的值是否有效 RST、SYN、FIN：用于连接的建立和断开。 CWR、ECE：拥塞明确。 PSH：数据是否立即交给上层。 URG：指示包含紧急数据。    序号和确认号 序号和确认号是TCP首部中最重要的两个字段。一个报文段的序号是报文段首字节的字节流编号。 假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0,第二个报文段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP 报文段首部的序号字段中。 确认号用于接收端向发送端发送已经接收到的正确顺序报文段中，序号最大的报文段。也就是主机正在等待的数据的下一个字节的序号 3.5.3 往返时间的估计和超时 TCP采用超时/重传机制来处理报文段的丢失问题，那么如何设置超时间隔呢。
估计往返时间 RTT（SimpleRTT ）:某报文段被发出（交给IP）到对该报文的确认被收到之间的时间间隔。 由于路由器的拥塞，报文段的RTT会随时间波动，TCP维持一个RTT的均值（EstimatedRTT)，一旦获得一个新的R TT，TCP采用下列公式来更新EstimatedRTT： 其中参数a推荐值为0.125，下图是一个RTT和EstimatedRTT的曲线的举例 ￼ DevRTT ：RTT偏差，用于估算SampleRTT 一般会偏离EstimatedRTT的程度，RTT波动较小，则DevRTT值就很小。 设置和管理重传超时间隔 超时间隔被定义为上式，初始Timeoutinterval为1秒，当出现超时后，Timeoutinterval值将加倍，再次接收报文段后，再使用上式计算Timeoutinterval。
3.5.4 可靠数据传输 英特网网络层（IP服务）是不可靠的，IP服务的数据报可能会溢出路由器缓存而丢失；也可能是乱序到达；数据报中的比特还可能会损坏（0变成1）。 TCP在IP不可靠的尽力而为的服务上创建了一种可靠数据传输服务，确保一个进程从其接收缓存中读取的数据流是无损坏、无间隙、非冗余、按序的数据流。下图给出了TCP发送方的高度简化描述。 NextSeqNum为数据报序号。 SendBase为已经经过确认的数据报的最大序号。 NextSeqNum和SendBase的差组成了窗口。]]></description>
</item><item>
    <title>Conda常用命令</title>
    <link>https://ZevaXu.github.io/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
    <pubDate>Tue, 20 Apr 2021 10:29:20 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://ZevaXu.github.io/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
    <description><![CDATA[conda常用命令 1. 管理conda   查看conda版本
1  conda --version     查看python版本
1  conda --python     进入/退出python环境
1 2  python quit()     更新conda版本
1  conda update conda      2. 管理环境   创建一个环境
1  conda create --name python34 python=3.4 #创建一个名为python34的环境，指定python版本为3.4     切换环境
1 2 3 4  #windows activate python34 #mac/linux source activate python34     删除一个已有的环境]]></description>
</item></channel>
</rss>
