[{"categories":["NoteBook"],"content":"3 基础数据类型 虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。进一步将这些数组织在一起，就可表达更多的对象。 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.1 整型 基础类型 有符号： int8、int16、int32、int64四种 无符号： uint8、uint16、uint32、uint64四种 rune：对应int32，表示一个Unicode码点。这两个名称可以互换使用 byte：是uint8类型的等价类型，强调数值是一个原始的数据而不是一个小的整数。 int：32位操作系统—int32、64位操作系统—int64 uintptr:一种无符号的整数类型,没有指定具体的bit大小但是足以容纳指针. 类型转换 算术和逻辑运算的二元操作中必须是相同的类型，所以int32和int64不能直接相加减。 显示类型转换： var compote = int(apples) + int(oranges) 对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度。 浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.2 浮点数 Go语言提供了两种精度的浮点数，float32和float64。 float32 1.4e-45～3.4e38； 精度到6个十进制位 float64: 4.9e-324～1.8e308 精度到15个十进制位 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.3 复数 Go语言提供了两种精度的复数类型：complex64和complex128。 内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部： var x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.Println(x*y) // \"(-5+10i)\" fmt.Println(real(x*y)) // \"-5\" fmt.Println(imag(x*y)) // \"10\" //也可以如下定义 x := 1 + 2i y := 3 + 4i 复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.4 布尔型 一个布尔类型的值只有两种：true和false。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.5 字符串 一个字符串是一个不可改变的字节序列。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。 内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i\u003c len(s)条件约束。 s := \"你好\" fmt.Println(len(s)) // 6 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变；但是可以给一个字符串变量分配一个新字符串值。 s := \"你好\" fmt.Println(\"开始: %d\\n\", len(s)) //6 t := \"不好？\" s = t fmt.Println(\"后来: %d\\n\", len(s)) //9 不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.5.1 字符串字面值 Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。 常用转义字符： ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:1","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.5.2 Unicode Unicode收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点， Unicode码点对应Go语言中的rune整数类型。 我们可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样的大小32bit来表示。此方式简单统一，但是会浪费很多存储空间。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:2","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.5.3 UTF-8 UTF8是一个将Unicode码点编码为字节序列的变长编码。现在已经是Unicode的标准。 UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于 表示总共有多少编码个字节。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符 每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。 Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。 s := \"你好，不好也好\" b := []byte(s) // [228 189 160 229 165 189 239 188 140 228 184 141 229 165 189 228 185 159 229 165 189] s2 := string(b) // \"你好，不好也好\" ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:3","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.6 常量 常量表达式的值在编译期计算，而不是在运行期。 每种常量的潜在类型都是基础类型：boolean、string 或数字。 常量声明 const pi = 3.14159 const ( e = 2.71828182845904523536028747135266249775724709369995957496696763 pi = 3.14159265358979323846264338327950288419716939937510582097494459 ) ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:6:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.6.1 iota常量生成器 在一个常量声明语句块中，每写一个语句，都会自增1。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:6:1","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"3.6.2 无类型常量 有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类 型的字符、无类型的浮点数、无类型的复数、无类型的字符串。 通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的 表达式而不需要显式的类型转换。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:6:2","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["NoteBook"],"content":"2.1 命名 命名规则： 字母和下划线开头，后可以接任何数量的字母、数字或下划线（区分大小写）。 不能使用go关键字来命名。 不推荐使用go预定义名字命名。 习惯用驼峰命名法。 可见性： 在函数内定义，仅函数可用。 在函数外定义，包级可用。 循环体的变量仅循环内可用。 名字开头的大小写决定了是否是导出型（外部是否可以访问） fmt.Printf() ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:1:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.2 声明 声明语句定义了程序的各种实体对象以及部分或全部的属性。主要有4种类型的声明语句： var：变量 const：常量 type：类型 func：函数 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:2:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.3 变量 声明变量的一般语法： var 变量名 类型 = 表达式 其中，类型和= 表达式两者可省略其一。编译器会自动推断变量的类型或者初始值。 各个类型的0值： 整型类型0值为0 布尔类型为false 字符串为\"\" 接口或引用类型（slice、map、chan、函数）变量对应nil 数组或结构体等聚合类型对应的0值为每个元素或字段对应的0值 包级变量在main函数执行之前完成初始化，局部变量在声明语句被执行到时完成初始化。 var i,j,k int var b,f,s = true,2.3,\"foo\" var f,err = os.Open(name) ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.3.1 简短变量声明 变量名 := 表达式 i := 0 i,j := 0,1 //声明+（可能赋值） i,j = j,i //赋值 左边为单个变量： 该变量必须为首次声明，语句即起到声明+初始化的作用。 左边为多个变量： 左边至少要有一个是首次声明的变量，对于该变量—声明+初始化；对于其他变量—仅仅赋值。 i := 0 i ++ i,j:= 2,3 j++  ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:1","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.3.2 指针 go中的指针对C语言中指针类型进行了一定的限制，使其变得更加安全。 指针的值和类型： 一个指针的值对应着一个变量在内存中的地址。 一个指针的类型对应其值对应的内存地址中存储的元素类型。 var x int addr := \u0026x  那么addr的类型为*int，addr被称为“指向int类型的指针”，保存了x变量的内存地址。 指针运算符： \u0026x:取地址操作 *addr:取值操作 优先级很高，高于自增、自减语句 i := 0 i++ t := \u0026i fmt.Println(i, t)//1 0x140000140a0 fmt.Println(*t)//1 fmt.Println(\u0026*t)//0x140000140a0 fmt.Println(*\u0026*t)//1  指针类型的0值为nil。 指针之间也可以比较，当取值（地址）相同或者全部为nil时，才相等。 var x, y int fmt.Println(\u0026x == \u0026x, \u0026x == \u0026y, \u0026x == nil) // \"true false false\" go语言中局部变量的地址也是安全的： var p = f() func f() *int { v := 1 return \u0026v } ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:2","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.3.3 new函数 另一个创建变量的方法是调用用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 p := new(int) // p, *int 类型, 指向匿名的 int 变量 fmt.Println(*p) // \"0\" *p = 2 // 设置 int 匿名变量的值为 2 fmt.Println(*p) // \"2\" ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:3","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.3.4 变量的生命周期 变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。 包一级声明的变量:生命周期和整个程序的运行周期是一致的。 局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:4","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.4 赋值 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:4:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.4.1 元组赋值 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。 x, y = y, x a[i], a[j] = a[j], a[i] ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:4:1","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.4.2 可赋值性 在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。 目前来说的规则： 赋值要求类型必须完全匹配； nil可以赋值给任何指针或引用类型的变量。 常量有更加灵活的赋值规则。 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:4:2","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.5 类型 变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。 类型声明语句： type 类型名字 底层类型 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用。目前中文汉字作为不能导出的类型。 package tempconv import \"fmt\" type Celsius float64 // 摄氏温度 type Fahrenheit float64 // 华氏温度 const ( AbsoluteZeroC Celsius = -273.15 // 绝对零度  FreezingC Celsius = 0 // 结冰点温度  BoilingC Celsius = 100 // 沸水温度 ) func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) } 为什么要像上述代码自定义类型： 为了语义上的考虑，虽然Celsius，Fahrenheit都是float64类型，但是其语义不同，刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误； 一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型。 命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。 比较运算符==和\u003c也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型 的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较： var c Celsius var f Fahrenheit fmt.Println(c == 0) // \"true\" fmt.Println(f \u003e= 0) // \"true\" fmt.Println(c == f) // compile error: type mismatch fmt.Println(c == Celsius(f)) // \"true\"! ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:5:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.7 作用域 作用域和生命周期： 声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。 一个变量的生命周期是指程序运行时变量存在（声明到被回收）的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。 作用域： 语法块内部声明的名字是无法被外部语法块访问的。 语法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧对应的语法块那样。 有一个语法块为整个源代码，称为全局语法块；然后是每个包的包语法决；每个for、if和switch语句的语法决；每个 switch或select的分支也有独立的语法决；当然也包括显式书写的语法块（花括弧包含的语句）。 内置的类型、函数和常量，比如int、len和true 等是在全局作用域的，因此可以在整个程序中直接使用。 包级声明的可以在一个包中的任何源文件中访问。 导入的包，只有当前go文件可用。 局部作用域仅局部可用。 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:6:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"2.8 包的概念 声明属于哪个包：package语句 go语言以包来组织代码，包类似其他语言中的库或者模块。每个包中可以包含多个xxx.go文件，这些go文件的命名没有要求。其内部第一行的packge xxx 代码规定了该文件归属于哪个包。 package main import { \"fmt\" \"math/rand\" \"time\" } var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) fmt.Println(math.pi) rand.Seed(time.Now().UnixNano()) } 对于应用程序（可以运行的程序）来说，必须要有一个main包，main包下可以包含若干个go文件，但是必须有且仅有一个go文件中包含一个main函数，作为程序的入口。 对于供其他人使用的模块(库)来说，可以没有main包。 导入包：import 语句 一个go文件中，以大写字母开头命名的函数称为可导出的函数，也就是可以给外界显示调用；以小写字母开头命名的函数称为不可导出的函数，外界无法调用。此规则适用于（变量、常量、函数、定义类型和类型别名）。 用import xxx导入一个包后，即可使用其中的资源，使用时需要加上包名xxx.funcA。 当没有导入需要用到的包或者导入了没有用到的包，go编译器都无法编译通过。 查找包 https://golang.org/pkg https://godoc.org/ 中可以找到标准库和社区写的包。 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:7:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["NoteBook"],"content":"链路层和局域网 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:0:0","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"6.1 链路层概述 在本章中，将运行链路层协议的任何设备称为节点，节点包括主机、路由器、交换机和wifi接入点。把沿着通信路径连接相邻的通信信道称为链路。 该数据报将实际通过6段链路：发送主机与WiFi接入点之间的WiFi链路，接入点和链路层交换机之间的以太网链路，链路层交换机与路由器之间的链路，两台路由器之间的链路，最后是交换机和服务器之间的以太网链路。在通过特定的链路时，传 输节点将数据报封装在链路层帧中，并将该帧传送到链路中。 注意到这3段运输是由不同的公司管理，使用了完全不同的运输方式（豪华大轿车、飞机和火车）。尽管运输方式不同，但它们都提供了将旅客从一个地点运输到相邻地点的基本服务。在这个运输类比中，一个游客好比一个数据报，每个运输区段好比一条链路，每种运输方式好比一种链路层协议，而该旅行社好比一个路由选择协议。 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:1:0","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"6.1.1 链路层提供的服务 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:1:1","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"6.4 交换局域网 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:0","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"6.4.1 链路层寻址和ARP 交换机运行在链路层，它们交换链路层帧，不识别网络层地址。 网络层和链路层都需要地址。 1. MAC地址 并不是主机或路由器具有链路层地址，是它们的适配器（网卡、网络接口）具有链路层地址。 MAC地址（LAN 地址、物理地址），长度为6字节，被设定为永久的（但是软件可以改变）。 IEEE管理着MAC地址的分配，网卡厂商生产网卡时，IEEE固定一个MAC地址的前24比特，后面毕业由厂商自己分配。 无论机器在何方，MAC地址总是不会变，不像IP地址具有层次结构，在不同的局域网，IP地址会改变。（MAC地址像身份证号，IP地址像邮政编码） 当某些适配器要向另一目的适配器发送一个帧，源适配器将包含目的适配器MAC地址插入到该帧中，发送到局域网。适配器接收到帧，与自己的MAC地址匹配，匹配上则接收，不匹配则丢弃。 当适配器想让局域网内所有适配器都接收一个帧，就插入一个特殊的MAC广播地址（48个1，FF- FF- FF- FF- FF- FF） 为什么既要MAC地址，又要IP地址？ IP地址工作在网络层，MAC地址工作在链路层。 局域网是为了任意网络层协议而设计的，不仅仅是IP和HTTP，如果适配器被分配为IP地址，而不是MAC地址，那么将不能方便的支持其他网络层协议。 如果适配器使用网络层地址，而不是MAC地址，那么适配器缓存必须存储IP地址，每次改变都要重新配置。 如果适配器不使用地址，IP数据报向上网络层传递，网络层根据数据报携带的目的地址匹配，那么对于每个帧，主机都将花费时间和资源去处理。 总而言之，不同的层需要它们自己的寻址方案，目前，我们看到有3种类型的地址：应用层的主机名、网络层的IP地址、链路层的MAC地址。 2. 地址解析协议ARP 地址解析协议：完成网络层IP地址和链路层MAC地址的转换，将IP地址解析为MAC地址（DNS将主机名解析为IP地址）。ARP只为在同一个子网上的主机和路由器解析IP地址。 ARP表： 每个主机和路由器在内存中都有一个ARP表，该表包含了IP地址到MAC地址的转换，每条记录都有一个生存时期（一般20分钟），ARP表不一定记录了局域网内所有主机IP和MAC的条目。 当ARP表中没有目的主机对应的MAC地址时： 源主机向适配器传递一个包含MAC广播地址的ARP查询分组 子网上所有的适配器都能接收该分组，并向上传递给其ARPmo模块 IP地址匹配的适配器会发送一个ARP响应分组 源主机更新其ARP表 查询ARP报文在广播帧中发送，响应ARP报文在标准帧中发送。 ARP表是即插即用的，自动建立，当主机与子网断开，其他主机内存中的ARP表最终也不会保留该主机的记录。 ARP表既包含网络层IP地址，也包含链路层MAC地址，所以该协议是跨链路层和网络层边界的协议。 发送数据报到子网以外 右上角主机A向右下角主机B发送数据。 A发送的数据报携带B的IP地址和路由器的MAC地址 路由器接收到数据报，更具其ARP表，转发携带B的IP地址和B的MAC地址的数据报 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:1","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"6.4.2 以太网 以太网是到目前为止最流行的有线局域网技术，而且到可能预见的将来它可能仍保持这一位置。 集线器： 工作在物理层，作用于比特而不是帧，当表示一个0或者1的一个比特到达一个接口，集线器重新生出这个比特，并将其能量强度放大，将该比特向其他所有接口传输出去。 因此，集线器下的是一个广播局域网。并且当同时收到两个接口发来的帧时，将发生碰撞，生出该帧的节点必须重传。 1. 以太网帧结构 ​ 数据(46~1500字节)：承载IP数据报。MTU（最大传输单元），一般为1500字节，如果IP数据报超过1500，主机必须将数据报分片；最小为46字节，如果小于46字节，数据报必须被填充到46字节（利用IP数据报中长度字节去除填充部分）。 目的地址(6字节)：目的适配器的MAC地址。当目的适配器收到一个以太网帧，当该帧中的目的地址是自身地址或者是广播地址时，该适配器将帧的数据字段内容传给网络层；当收到其他MAC地址的帧，丢弃之。 源地址(6字节)：包含了传输该帧到局域网上的适配器MAC地址。 类型字段(2字段)：指定了数据帧的不同网络层协议。 CRC(4字节)：循环冗余检测，使得接收适配器检测帧是否引入了差错。 前同步码(8字节)：前7个字节用于同步两个适配器的时钟；第8个字节提示重要的内容就要到了。 以太网技术向网络层提供服务的特点： 无连接服务：即发生前不需要事先握手。 不可靠：当CRC校验通过时，也不回送确认帧；没有通过时，简单丢弃。因此发生方根本不知道接收方是否正确收到了发送的帧（可靠服务由网络层的TCP来提供）。（因为简单，使用广泛） 2. 以太网技术 随着时代的发展，以太网演化出多种协议，如10BASE-T、 10BASE-2、100BASE-T、1000BASE-LX和10GBASE-T等。其命名的首部数字代表速率，base指基带以太网，后面的字母代表传输介质，双绞铜线、光纤等。 在演化过程中，初始的以太网MAC协议和帧格式被保留了下来。 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:2","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"6.4.3 链路层交换机 交换机的任务时接收入链路层帧，并将它们转发到出链路，交换机对于子网中的主机和路由器是透明的。 1 交换机转发和过滤 过滤（filtering）是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。 转发（forwarding）是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。 交换机表 交换机的过滤和转发借助交换机表完成。 交换机表包含某个局域网上某些主机和路由器的非全部的表项。如下 假定目的地址为DD-DD-DD-DD-DD-DD的 帧从交换机接口x到达。交换机用MAC地址DD-DD-DD-DD-DD-DD索引它的表。 如果找不到目的MAC地址，交换机则广播该帧。 如果有接口y的MAC地址和目的地址对应，直接转发。 2. 自学习 交换机的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。 换句话说，交换机是自学习（self-leaming） 的、即插即用的。 交换机初始表为空。 对于每个借口接收到每个帧，交换机记录其源MAC地址、到达的接口、当前时间。 在一段时间后（老化期），超时删除表项。 3. 链路层交换机的性质 不同于总线、集线器的星形拓扑结构，使用交换机有如下特点。 消除碰撞：不会因为碰撞而浪费带宽。 异质的链路：交换机将链路彼此隔离，局域网中不同的链路能够以不同的速率传输。 管理：能够检测到异常的适配器（持续发送帧、断开连接等），也可收集带宽使用的统计数据、碰撞率、和流量类型等。 4. 交换机和路由器的比较 同：路由器和交换机都是存储转发分组的交换机。 异：路由器是使用网络层地址转发分组的存储转发分组交换机。而交换机是用MAC地址转发的，交换机工作在链路层，路由器工作在网络层。 ​ 交换机优缺点： 即插即用 较高的速率过滤和转发分组 网络拓扑结构呈树形 大型交换机网络ARP表大 没有广播网络处理措施 路由器的优缺点： 没有生成树限制，有更丰富的拓扑结构 非即插即用，需要人为配置IP地址 每个分组处理时间比交换机长 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:3","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"6.4.4 虚拟局域网 虚拟局域网：VLAN，支持VLAN的交换机允许经一个单一的物理局域网 基础设施定义多个虚拟局域网。在一个VLAN内的主机彼此通信，仿佛它们（并且没有其他主机）与交换机连接。 如上图，电子工程系流量如何发送到计算机科学系呢？ 将一个端口（1）与外部路由器连接，并将该端口设置为同属于EE VLAN和CS VLAN，。从电子工程系发 往计算机科学系的数据报将首先跨越EE VLAN到达路由器，然后由该路由器转发跨越CS VLAN到达CS主机。 VLAN干线连接 每台交换机上的一个特殊端口（左侧交换机上的端口 16,右侧交换机上的端口 1）被配置为干线端口，以互联这两台VLAN交换机。 由标准以太网帧与加进首部的4字节VLAN标签（VLAN tag）组成，而VLAN 标承载着该帧所属的VLAN标识符。 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:4","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"6.6 数据中心网络 每个数据中心都容纳了数万至数十万台主机, 并且同时支持着很多不同的云应用（例如搜索、电子邮件、社交网络和电子商务）。每个数据中心都有自己的数据中心网络（data center network）,这些数据中心网络将其内部主机彼此互联并与因特网中的数据中心互联。 数据中心中的主机称为刀片（blade）,与比萨饼盒类似，一般是包括CPU、内存和磁盘存储的商 用主机。主机被堆叠在机架上，每个机架一般堆放20-40台刀片。在每一个机架顶部有一台交换机，这台交换机被形象地称为机架顶部（Top of Rack, TOR）交换机，它们与机架上的主机互联，并与数据中心中的其他交换机互联。具体来说，机架上的每台主机都有一块与TOR交换机连接的网卡，每台TOR交换机有额外的端口能够与其他TOR交换机连接。 数据中心网络设计是互联网络和协议设计的艺术，该艺术专注与机架彼此连接和与边界路由器相连接。 在数据中心内部, 外部请求首先被定向到一个负载均衡器（load balancer）。负载均衡器的任务是向主机分发 请求，以主机当前的负载作为函数来在主机之间均衡负载。 负载均衡器基于分组的目的端口号和目的IP地址做出决策，将客户的请求打到某一台主机。 主机处理完请求后，向负载均衡器回送响应，负载均衡器再将其中继给客户。 负载均衡器不仅平衡主机间的工作负载，还提供类似NAT的功能，将外部IP转换为内部IP，从而提供了安全性。 2. 等级体系结构 当主机规模扩张到几万台，数据中心通常应用路由器和交换机等级结构，并且还提供冗余链路，比如没太TOR交换机能够与2台第二层交换机连接等。 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:3:0","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["NoteBook"],"content":"网络层协议 ​ 控制平面作为一种网络范围的逻辑，不仅控制沿着从源主机到目的主机的端到端路径间的路由器如何转发数据报，而且控制网络层组件和服务如何配置和管理。 OSPF是一种运行在单一ISP的网络中的路由选择算法。BGP是一种在因特网中用于 互联所有网络的路由选择算法，因此常被称为因特网的“黏合剂” 。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["NoteBook"],"content":"5.2 路由选择算法 其目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径(等价于路由)。通常，一条好路径指具有最低开销的路径。 分类 根据该算法是集中式还是分散式 集中式路由选择算法：用完整的、全局性的网络知识计算岀从源到目的地之间的最低开销路径。 要求该算法在真正开始计算以前，要以某种方式获得这些信息。 具有全局状态信息的算法常被称作链路状态(Link State, LS) 算法。 分散式路由选择算法：没有节点拥有关于所有网络链路开销的完整信息。 相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后，通过迭 代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或 一组目的节点的最低开销路径。 根据算法是静态的还是动态 在静态路由选择算法(static routing algorithm)：路由随时间的变化非常缓慢，通常是人工进行调整(如人为手工编辑一条链路开销) 。 动态路由选择算法(dynamic routing algorithm) ：随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路开销的变化而运行。 根据它是负载敏感的还是负载迟钝的进行划分 负载敏感算法：链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该 拥塞链路来选择路由。 负载迟钝算法：某条链路的开销不明确反映当前或者最近的拥塞水平。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:1:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["NoteBook"],"content":"5.2.2 距离向量路由选择算法 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:1:1","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["NoteBook"],"content":"5.3 因特网中自治系统内部的路由选择:OSPF 上述讨论的LS（狄杰斯特拉）和距离向量路由选择协议都不能适用于整个网络，原因有如下两点： 网络规模。当今的因特网由数亿台主机组成。在这些主机中存储的路由选择信息显然需要巨大容量的内存。并且求出所有路由器之间的链路开销需要巨大的负担，并且距离向量算法可能永远无法收敛。 管理自治。因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器(如在自己的网络中运行它所选择的某种路由选择算法)，或对外部隐藏其网络的内部组织面貌。 自治系统（AS）：一个自治系统由其全局唯一的AS号(ASN)所标识。每个AS由一组通常处在相同管理控制下的路由器组成。 通常在一个ISP中的路由器以及互联它们的链路构成一个AS；也有某些ISP将网络划分为多个AS；也有一个一级ISP在整个网络使用一个庞大的AS，其他子ISP再进行划分为多个AS。 开放最短路优先(OSPF) OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。 使用OSPF, —台路由器构建了一幅关于整个自治系统的完整拓扑图(即一幅图)。于是, 每台路由器在本地运行Dijkstra的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。 各条链路开销是由网络管理员配置，管理员也许会选择将所有链路开销设为1,因而实现了最少跳数路由选择，或者可能会选择将链路权值按与链路容量成反比来设置，从而不鼓励流量使用低带宽链路。 使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时(如开销的变化或连接/中断状态的变化)，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地 (至少每隔30 min一次)广播链路状态 。 优点： 安全。路由器间的OSPF报文能够配置两类鉴别，即简单的和MD5的。使用简单的鉴别，每台路由器配置相同的口令。当一台路由器发送一个OSPF分组，它以明文方式包括了口令 。MD5的要对比报文携带的MD5散列和路由去计算出来的MD5值。 多条相同开销的路径。当到达某目的地的多条路径具有相同的开销时，OSPF允许使用多条路径。 对单播与多播路由选择的综合支持。 支持在单个AS中的层次结构。一个OSPF自治系统能够层次化地配置多个区域。 每个区域都运行自己的OSPF链路状态路由选择算法，区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。 区边界路由器：即在子区中，又在主干网络区中。“汇总” 到达所在区网络的距离, 通告给其他区边界路由器。 主干路由器( Backbone Routers):在主干区内运行OSPF路由算法。 AS边界路由器：连接其他AS。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:2:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["NoteBook"],"content":"5.4 ISP之间的路由选择：BGP BGP(Broder Bateway Protocal)：边界网关协议。 热土豆路由选择依据的思想 对于路由器lb,尽可能快地将分组送出其AS (更明 确地说，用可能的最低开销)，而不担心其AS外部到目的地的余下部分的开销。就 “热 土豆路由选择”名称而言，分组被类比为烫手的热土豆。因为它烫手，你要尽可能快地将它传给另一个人(另一个AS)。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:3:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["NoteBook"],"content":"5.6 ICMP：英特网控制报文协议 ICMP，被主机和路由器用来彼此沟通网络层的信息，典型的用途是差错报告。 例如HTTP会话中的“404 网络不可到达“等。 在某个位置，IP路由器不能找到一条通往HTTP请求中所指定的主机的路径，该路有趣就会向你的主机生成并发出一个ICMP报文以提示该错误。 ICMP报文是作为IP有效承载的，就像TCP和UDP报文段作为IP有效承载那样。ICMP有一个类型字段和一个编码字段，并且包含引起该IP数据报的首部和前8个字节。 Ping：ping程序发送一个ICMP类型8编码0的报文到指定主机，看到回显请求，目的主机发回一个类型0编码0的ICMP报文。 Traceroute:由ICMP报文实现。 源主机向目的主机发送一系列普通IP数据报，每个数据报包含一个不可到达的UDP端口号的UDP报文段 第一个数据报的TTL为1，第二个为2，以此类推 当第n个书记报到达第n台路由器，刚好过期，路由器丢弃该数据报，并发送一个ICMP警告报文给源主机（类型11，编码为0），该告警报文包含了路由器的名字和它的IP地址。 当目的主机收到报文时，由于端口不可到达，它向源主机发送一个端口不可到达的ICMP报文（类型3，编码3），当源主机接收到该报文，它就停止发送类似数据报。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:4:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["NoteBook"],"content":"可靠数据传输协议原理 ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:0:0","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["NoteBook"],"content":"构造可靠传输协议 可靠数据传输协议是由 检验和、序号、定时器、肯定和否定确认这几个机制来确保的。 其中检验和用于接收方判断分组是否发生错误，序号帮助发送方决定重新发送哪个分组，接收方发送肯定和否定确认告诉发送方是否正确接收到了分组。 将发送方称为S，接收方成为R，考虑以上几种情况： 一切正常 S向R发送0号分组，R收到了分组，利用检验和判断分组是否正确，如果正确，R向S发送一个0号分组的ACK确认分组，告诉S已经收到了正确分组。S再向R发送下一个分组1。 分组丢失 S向R发送0号分组，此时S的定时器开始计时，0号分组在传输过程中丢失，R没有收到任何数据，所以也没有向S发送任何确认信号。当计时器停止时，S向R在发送一个0号分组。 ACK丢失 S向R发送0号分组，并开启了定时器。R收到了分组，并回传一个ACK信号，但是信号在传输过程中丢失，当S的定时器停止时，S会再向R发送相同分组，此时R再次收到了相同的分组，开启冗余检测机制，会丢弃冗余的分组。 过早超时 S向R发送0号分组，并开启了定时器。R收到了分组，并回传一个ACK信号，但是信号在传输过程中超时，S又发了一个相同的分组给R，之后S收到该上一个分组ACK，但是它什么也不做。 ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:1:0","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["NoteBook"],"content":"流水线可靠数据传输协议 如果采取“可靠数据传输协议”：接收一个分组，等待一个ACK到达后，再发送下一个分组的方式，发送发大部分时间都处于等待中，会带来有效吞吐量小，发送方利用率低的缺陷。 引入流水线技术有助于解决这种缺陷。即不以停等的方式运行，允许发送方发送多个分组而无须等待确认。 这样的技术提出如下几个要求： 增加序号的范围，每个分组必须有一个唯一的序号，有多个再输送中而未被确认的分组 发送方和接收方两端需要缓存多个分组。发送方最低限度要缓存那些已经发送但没有确认的分组。 解决流水线的差错恢复有两种基本方法：回退N步（go-back-N,GBN)、选择重传(Selective Repeat,SR) ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:2:0","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["NoteBook"],"content":"GBN(回退N步) 窗口长度N由包括两部分（已发送但未被确认的分组和可用但是还没有发送的分组序号）组成。 一个分组的序号承载在分组首部的一个固定长度字段中规定，例如如果只分配1比特给这个字段，那么这个序号空间只能是0和1。 GBN的运行过程如下图： 发送方批量发送多个分组，并为每个已经发送的分组开启一个定时器，接收方按序接收分组，每接收到一个分组，发送一个ACK。 例如发送方批量发送了0—4号分组，其中3号分组丢失。 对于发送方：它的3号计时器到期后，就把3号及3号之后的分组再重新发送； 对于接收方：它收到了0、1、2号分组，每收到一个就发送该分组的ACK。由于未收到3号分组，它接收到4号分组后，把4号分组丢弃，再发送上一个正确分组的ACK，即2号ACK。直到接收到3号分组为止。 GBN协议允许发送方用多个分组填充流水线，因此避免了停等协议中的信道利用率问题，使用到了序号、累计确认、检验和、超时重传操作等技术。 ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:2:1","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["NoteBook"],"content":"选择重传 GBN协议也存在一些性能问题，当窗口长度和传输时延过大时，单个分组的差错带来的大量不必要重传的分组再次重传。 选择重传协议通过让接收方缓存没有确认的分组以及维护一个窗口的方式，实现发送方仅仅重传接收方没有收到或者受损的分组。 分组重新排序问题： 分组重新排序的表现：一个具有序号或者确认号x的分组的旧副本可能突然出现。 当信道是一个网络时，分组重新排序是可能发生的，此时，网络相当于缓存了分组，并随时可能把分组释放出来。 解决： 确保一个序号不被重新使用，假定分组在网络中的存活时间最大为3分钟。 ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:2:2","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["NoteBook"],"content":"TCP是因特网运输层的面向连接的可靠的运输协议。依赖于差错检测、重传、累计确认、定时器以及带有序号和确认号的首部字段，使得它可以在不可靠的IP协议之上，提供可靠的运输协议。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:0","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["NoteBook"],"content":"3.5.1 TCP连接概述 TCP是面向连接的。这里的连接指的是一两条逻辑连接，其共同状态包括要维护的参数、TCP缓存等,仅仅保留在两个通信端系统的TCP程序中。 *TCP是点到点的。即单个发送方和单个接收方之间的连接，其中发送方被称为客户端，接收端被称为服务器。 *建立连接的过程：客户先发送一个特殊（首部字段特殊）的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后客户端再用第三个特殊报文段作为响应，前两个报文段不承载任何应用层数据。这样一个建立连接的过程称为三次握手。 一旦建立起TCP连接，两个应用进程旧可以相互发送数据。客户进程将数据通过套接字传给TCP，TCP将这些数据存入发送缓存，接下来再陆续从发送缓存里取出数据，封装送给网络层。 *MSS（Maximum Segment Size,最大报文长度）：报文段里应用层数据的最大长度，不包括首部字段。 *MTU（Maximum Transmission Unit,最大传输单元）：包含TCP首部的报文段最大长度，以太网和PPP链路层协议都有1500字节的MTU，一个典型值是1460。 TCP连接的组成：客户端主机上的缓存、变量与套接字；服务器主机上的缓存、变量与套接字。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:1","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["NoteBook"],"content":"3.5.2 TCP报文段结构 TCP的首部一般是20字节，比UDP首部多12字节。 源端口号和目的端口号：用于多路复用/分解 32比特的序号字段/32比特的确认号字段：用于实现可靠数据传输 16比特的接收窗口字段，用于流量控制 4比特首部长度字段：指示了TCP的首部长度 可选与变长的选项字段：用于连接双方协商最大报文长度（MSS） 6比特的标志字段： ACK：指示确认字段中的值是否有效 RST、SYN、FIN：用于连接的建立和断开。 CWR、ECE：拥塞明确。 PSH：数据是否立即交给上层。 URG：指示包含紧急数据。 序号和确认号 序号和确认号是TCP首部中最重要的两个字段。一个报文段的序号是报文段首字节的字节流编号。 假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0,第二个报文段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP 报文段首部的序号字段中。 确认号用于接收端向发送端发送已经接收到的正确顺序报文段中，序号最大的报文段。也就是主机正在等待的数据的下一个字节的序号 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:2","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["NoteBook"],"content":"3.5.3 往返时间的估计和超时 TCP采用超时/重传机制来处理报文段的丢失问题，那么如何设置超时间隔呢。 估计往返时间 RTT（SimpleRTT ）:某报文段被发出（交给IP）到对该报文的确认被收到之间的时间间隔。 由于路由器的拥塞，报文段的RTT会随时间波动，TCP维持一个RTT的均值（EstimatedRTT)，一旦获得一个新的R TT，TCP采用下列公式来更新EstimatedRTT： DevRTT ：RTT偏差，用于估算SampleRTT 一般会偏离EstimatedRTT的程度，RTT波动较小，则DevRTT值就很小。 设置和管理重传超时间隔 超时间隔被定义为上式，初始Timeoutinterval为1秒，当出现超时后，Timeoutinterval值将加倍，再次接收报文段后，再使用上式计算Timeoutinterval。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:3","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["NoteBook"],"content":"3.5.4 可靠数据传输 英特网网络层（IP服务）是不可靠的，IP服务的数据报可能会溢出路由器缓存而丢失；也可能是乱序到达；数据报中的比特还可能会损坏（0变成1）。 TCP在IP不可靠的尽力而为的服务上创建了一种可靠数据传输服务，确保一个进程从其接收缓存中读取的数据流是无损坏、无间隙、非冗余、按序的数据流。下图给出了TCP发送方的高度简化描述。 NextSeqNum和SendBase的差组成了窗口。 三种情况 确认丢失 超时重传 确认丢失，但是没有超时 超时间隔加倍 TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，一旦收到确认，就立马使用EstimatedRTT值与DevRTT值推算得到超时间隔。 这种设定有助于拥塞控制，防止链路中有太多的数据报。 快速重传 冗余ACK：发送方已经收到了对该报文的确认，接收方再次发送该报文的ACK。 一旦收到3个冗余ACK, TCP就执行快速重传。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:4","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["NoteBook"],"content":"3.5.5 流量控制 TCP收到连续的、正确的字节后，就将数据放入接收缓存，等待应用程序取出（并不是一到达立马取出）。 当数据过多时，就可能溢出缓存。因此TCP提供了流量控制服务，以消除发送方使接收方缓存溢出的可能性。 流量控制是一个速度匹配服务，即发送方的发送速率与接收方的应用程序读取速率相匹配。 TCP通过记录并发送缓存空闲空间的大小来实现流量控制 当rwnd等于0时，主机A作为发送方，继续发送只有一个字节的报文，这些报文段将会被接收方B确认，但B的缓存被清空后，确认报文里将包含一个非0的 rwnd值。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:5","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["NoteBook"],"content":"3.5.6 TCP连接管理 连接的建立 客户端发送SYN报文段。 客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段，该报文段不包含任何应用层数据，但是首部一个标志位（SYN）被设置为1。这个特殊报文段被称为SYN报文段。另外，客户会随机地选择一个初始序号（client-isn）,并将此编号放置于该起始的TCP的SYN 报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。 服务器回传SYNACK报文段。 当TCP的SYN报文段的IP数据报到达服务器主机，服务器从数据报中提取出TCP的SYN报文段，并为TCP连接分配TCP缓存和变量。并回送一个允许连接的报文段，这个报文段不包含任何应用层数据，首部的SYN字段也为1，确认号字段为client-isn+1 ，并选择自己的初始序号sever-isn，将其放到TCP首部的序号字段。含义：“我收到了你发起建立连接的SYN分组，该分组带有初始序号 clientjsno我同意建立该连接。我自己的初始序号是server-isn”。 连接建立。 在收到SYNACK后，客户端给给该连接分配缓存和变量。再发送一个报文段，在确认字段设置为server-isn + 1，并且SYN字段设置为0，该阶段的报文段可以携带客户到服务器的数据。连接建立后，后续报文段中的SYN字段都被置为0。 连接的终止 参与TCP连接的两方任意一方都可终止该连接。当连接结束后，主机中的缓存和变量都将被释放。 假设客户端打算关闭TCP连接。 客户向服务器发送一个特殊报文段，其FIN字段设置为1. 服务器接收到该报文段，回送一个确认报文段，然后也发送足迹的FIN为1的终止报文段 客户对这个报文段进行确认，随后两台主机上关于该连接的所有资源都被释放。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:6","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["NoteBook"],"content":"conda常用命令 ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["NoteBook"],"content":"1. 管理conda 查看conda版本 conda --version 查看python版本 conda --python 进入/退出python环境 python quit() 更新conda版本 conda update conda ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["NoteBook"],"content":"2. 管理环境 创建一个环境 conda create --name python34 python=3.4 #创建一个名为python34的环境，指定python版本为3.4 切换环境 #windows activate python34 #mac/linux source activate python34 删除一个已有的环境 conda remove --name python34 --all 列出所有环境 conda info -e #conda info -envs 复制一个环境 conda create -n flowers --clone python34 ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["NoteBook"],"content":"3. 管理包 conda安装和管理python包非常方便，可以在指定的python环境中安装包，且自动安装所需要的依赖包，避免了很多拓展包冲突兼容问题。 不建议使用easy_install安装包。大部分包都可以使用conda安装，无法使用conda和anaconda.org安装的包可以通过pip命令安装 使用合适的源可以提升安装的速度 ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["NoteBook"],"content":"3.1 使用conda命令安装 查看该环境中已经安装的包 conda list 在指定环境中安装指定包 #1.直接指定 conda install --name python34 beautifulsoup4 #2. 进入指定环境再安装 source activate python34 #windou s系统去除 source ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["NoteBook"],"content":"3.2 从Anaconda.org安装一个包 如果一个包不能使用conda安装，我们接下来将在Anaconda.org网站查找。 在浏览器中，去 Anaconda资源官网。我们查找一个叫“bottleneck”的包，所以在左上角的叫“Search Anaconda Cloud”搜索框中输入“bottleneck”并点击search按钮。 Anaconda.org上会有超过一打的bottleneck包的版本可用，但是我们想要那个被下载最频繁的版本。所以你可以通过下载量来排序，通过点击Download栏。 点击包的名字来选择最常被下载的包。它会链接到Anaconda.org详情页显示下载的具体命令： conda install--channel https：//conda .anaconda.ort/pandas bottleneck ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:2","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["NoteBook"],"content":"3.3 pip命令安装 对于那些无法通过conda安装或者从Anaconda.org获得的包，我们通常可以用pip命令来安装包。 pip只是一个包管理器，所以它不能为你管理环境。pip甚至不能升级python，因为它不像conda一样把python当做包来处理。但是它可以安装一些conda安装不了的包。 可以上pypi网站查询要安装的包，查好以后输入pip install命令就可以安装这个包了。 我们激活想要放置程序的python环境，然后通过pip安装一个叫“See”的程序。 pip install see ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:3","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["NoteBook"],"content":"3.4 文件源码安装 如果真的遇到走投无路的境地，也就是上面这些方法通通不管用！！！那就只能下载源码安装了，比如exe文件（双击安装）或者whl文件（pip安装）等等。还有在github上找到源码，使用python setup.py install命令安装。 ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:4","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["NoteBook"],"content":"3.5 移除 移除一个包 conda remove -n beautifulsoup4 移除环境 conda remove -n python34 --all 移除conda #linux rm -rf ~/miniconda #或者 rm -rf ~/anaconda #或者 4. 频道管理 列出所有channel conda config --show channels #或者 conda config --get channels 追加channel conda config --append channels CHANNEL_NAME #并没有改变优先级 设定首要channle conda config add channels conda-forge #将此channel设定为第一优先级 删除channel conda config --remove channels NOT_WANTED 添加清华源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 源 #豆瓣 https://pypi.douban.com/simple/ #默认源 https://pypi.org/simple ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]