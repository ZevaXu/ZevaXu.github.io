[{"categories":["笔记"],"content":"复合数据类型 主要的四种复合数据类型： 数组：同构的元素组成，内存大小固定 结构体：异构元素组成，内存大小固定 切片：动态数据类型 映射：动态数据类型 ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.1 数组 数组是由固定长度的特定类型元素组成的序列，可以通过索引下标来访问，下标的范围从0到长度减1。 数组的定义 var a [3]int //根据元素类型的初始值来初始化 int类型初始值为0 var b [3]int = [3]{1,2,3} //自定义数组的初始值 // 也可以用简短声明 d := [...]int{1,2,3} //省略号 表示根据初始值个数来自动推断 当数组的元素是可比价的，那么数组也是可以比较的，仅当元素个数相等、所有元素都相等，数组才相等。 a := [2]int{1, 2} b := [...]int{1, 2} c := [2]int{1, 3} fmt.Println(a == b, a == c, b == c) // true,false,false 数组的长度等于其容量 Go语言函数调用传递参数的方式为值传递，即形参是实参的副本。这就导致传递大的数组类型是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。 ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.2 切片 Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T 代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。 切片的定义：类似数组但是没有指定元素个数，隐式创建一个合适大小的数组。 //1 不加索引 weekdays := []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"} //2 加索引 weekdays := []string{0: \"Sunday\", 1: \"Monday\", 2: \"Tuesday\", 3: \"Wednesday\", 4: \"Thursday\", 5: \"Friday\", 6: \"Saturday\"} // 3 加索引乱序(对数组也有效果) weekdays := []string{6: \"Saturday\", 0: \"Sunday\", 1: \"Monday\", 2: \"Tuesday\", 3: \"Wednesday\", 4: \"Thursday\", 5: \"Friday\"} 切片包含三部分属性，1是切片里的元素、2是切片的长度len()、3是切片的容量cap() 切片的容量总是不小于切片的长度。如果切片操作超出了容量上限，会导致恐慌；如果超出长度，就是扩展了切片。 fmt.Println(summer[:10])// 恐慌 fmt.Println(summer[:5])// [June July August September October] 由于切片在底层是共享的一个数组，所以对切片复制时，改变新的切片内容将会同时改变原来的切片。 months2 := months[:] months2[0] = \"Go\" fmt.Println(months) //[Go January February March April May June July August September October November December] fmt.Println(months2) //[Go January February March April May June July August September October November December] 不同于数组，切片是不能比较大小的，原因： 切片内元素是间接引用的，一个切片甚至可以包含自身。 一个切片可能在不同时间内包含不同的元素（底层的数组改变） 切片可以和nil比较： var s []int // len(s) == 0, s == nil s = nil // len(s) == 0, s == nil s = []int(nil) // len(s) == 0, s == nil s = []int{} // len(s) == 0, s != nil ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.2.1 append函数 内置的append函数用于向切片追加元素。 months := []string{1: \"January\", 2: \"February\", 3: \"March\", 4: \"April\", 5: \"May\", 6: \"June\", 7: \"July\", 8: \"August\", 9: \"September\", 10: \"October\", 11: \"November\", 12: \"December\"} fmt.Println(\"len:\",len(months), \"cap\",cap(months)) // len: 13 cap 13 fmt.Printf(\"%p \\n\", months) //0x14000064b60 months = append(months, \"Go\") fmt.Println(months) //[ January February March April May June July August September October November December Go] fmt.Println(\"len:\",len(months), \"cap\",cap(months)) // len: 14 cap 26 fmt.Printf(\"%p \\n\", months) //0x140000016c0 append函数的底层实现： 如果切片容量够，那么直接追加 如果不够，先建立一个容量更大的切片，复制原来的元素，再追加 append可以一次追加多个元素： months = append(months, \"Python\",\"C++\",\"Java\") ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:1","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.2.2 切片的内存技巧 修改新切片会照成原来切片的改变 func Remove_empty_string(strings []string) []string { i := 0 for _, j := range strings { if j != \"\" { strings[i] = j i++ } } return strings[:i] } func main() { s := []string{\"1\", \"\", \"3\"} fmt.Println(Remove_empty_string(s)) //[1,3] fmt.Println(s) // [1,3,3] 可以 s = Remove_empty_string(s) } 删除切片中间某个元素 通过copy()函数复制覆盖 func remove(slice []int, i int) []int { copy(slice[i:], slice[i+1:]) return slice[:len(slice)-1] } func main() { s := []int{4, 5, 6, 7} fmt.Println(remove(s, 2)) // [4 5 7] } ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:2","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.3 Map映射 哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同 的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。 所有的key必须是同一类型元素，value也必须是同一类型元素。 Map的创建 //1 ages := make(map[string]int) //键：string 值：int //2 ages := map[string]int{ \"alice\": 31, \"charlie\": 34, } //初始化 //3 ages := make(map[string]int) ages[\"alice\"] = 31 ages[\"charlie\"] = 34 删除元素 delete(ages, \"alice\") // remove element ages[\"alice\"] 上述操作是安全的，即使要删除的元素不在map中。 特点 如果查找map中元素失败，即无该key-value，那么会返回value的一个0值。 禁止对map中元素取地址，map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。 Map的迭代顺序是不确定的，遍历的顺序是随机的，每一次遍历的顺序都不相同。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。 map的零值是nil,即没有引用任何元素。 map的创建和初始化： var ages map[string]int // map的零值是nil，还没有创建。查找、删除、len和range循环都可以安全工作在nil值的map上，但是不可以存入元素 fmt.Println(ages == nil) // true fmt.Println(ages) // map[] ages[\"alice\"] = 31 // 引起panic age := make(map[string]int) // 创建map,可以存入元素 fmt.Println(age == nil) // false fmt.Println(age) // map[] age[\"alice\"] = 31 // 没有panic 查看键值对是否在map中： //age[\"alice\"] = 31 会返回两个值，一个是“alice”键对应的值，一个是“alice”键对应的值是否存在，不存在时，第一个值为0，第二个值为false。防止混淆 if age, ok := ages[\"alice\"]; ok { fmt.Println(age) } else { fmt.Println(\"alice is not in the map\") } ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.4 结构体 结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。 结构体的定义 // 结构体成员的顺序不同，结构体类型也不同。 type Employee struct { ID int Name string Address string Date time.Time Position string Salary int ManagerID int } var dilbert Employee // 初始化，用.来访问成员 dilbert = Employee{ ID: 123, Name: \"Dilbert\", Address: \"123 Acacia Road\", Date: time.Now(), Position: \"Senior Engineer\", Salary: 12345, ManagerID: 123, } 如果成员的名字是以大写字母开头，那么它就是对外的接口，可以被外部代码访问。 结构体成员类型不可以是它自己，因为一个聚合类型的值不能包含自身。但是，如果结构体成员类型是聚合类型的指针，那么它就可以包含自身。这可用于创建递归类型数据结构，链表和树结构。 type tree struct { value int left, right *tree } 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 ==或!=运算符进行比较。 结构体类型的零值是每个成员都是零值。 ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:0","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.4.1 结构体赋值 //1 适用于简单的结构体,要求赋值顺序一致 type Point struct { X, Y int } p := Point{1, 2} //2 适用于复杂的结构体，顺序不重要，如果有缺失的成员，则赋值为零值 p := Point{X: 1, Y: 2} ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:1","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.4.2 结构体和结构体指针 结构体和结构体指针的相同点： 实际都是指针 都可以用结构体名.成员名的方式访问成员 结构体和结构体指针的不同点： 用结构体指针会改变结构体的值，用结构体不会改变结构体的值 如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是 值拷贝传入的，函数参数将不再是函数调用时的原始变量。 type Rect struct { width, length float64 } //结构体形式 func double_area(rect Rect) float64 { rect.width *= 2 rect.length *= 2 return rect.width * rect.length } func main() { var rect = Rect{100, 200} fmt.Println(double_area(rect))//8000 fmt.Println(\"Width:\", rect.width, \"Length:\", rect.length)//Width: 100 Length: 200 } //结构体指针形式 func double_area(rect *Rect) float64 { rect.width *= 2 rect.length *= 2 return rect.width * rect.length } func main() { var rect = Rect{100, 200} fmt.Println(double_area(\u0026rect))//4000 fmt.Println(\"Width:\", rect.width, \"Length:\", rect.length)//Width: 200 Length: 400 } ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:2","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"4.4.3 结构体嵌入和匿名成员 结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。 结构体字面值并没有简短表示匿名成员的语法。 因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。 简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。 type Point struct { X, Y int } type Circle struct { Point Radius int } type Wheel struct { Circle Spokes int } var w Wheel w.X = 8 // w.Circle.Point.X = 8 w.Y = 8 // w.Circle.Point.Y = 8 w.Radius = 5 // w.Circle.Radius = 5 w.Spokes = 20 w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // 但是不能这样写 编译不通过 w = Wheel{ Circle: Circle{ Point: Point{X: 8, Y: 8}, Radius: 5, }, Spokes: 20, } ","date":"2021-12-20","objectID":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:3","tags":["Go"],"title":"Go:复合数据类型","uri":"/go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"7.1 概述 无线网络中的要素： 无线主机。可能移动、可能不动。 无线链路。主机通过无线通信链路连接到一个基站或者另外一个主机。 基站。负责向与之关联的无线主机发送数据和从主机那接收数据，协调与之相关联的多个无线主机的传输。如蜂窝塔、LAN接入点。 网络基础设施 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:1:0","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.2 无线链路和网络特征 有线网络和无线网络的重要区别主要在链路层，如： 递减的信号强度。电磁波在穿过物体和随之距离增加会减弱（路径损耗）。 来自其他源的干扰。同一个频段下发送信号的电波源将相互干扰。 多径传播。当电磁波的一部分受物体和地面反射，在发送方和接收方之间走了不同长度的路径，回造成信号模糊。 所以，无线链路中的比特差错比有线链路中更为常见。 信噪比(Signal-to-Noise,SNR)：所收到的信号和噪声强度的相对测量（越大越好）。 比特差错率(BER)：收到的有错传输比特的概率。 当调制方案一定，SNR越高，BER越低。发送方通过增加发送功率可以提高SNR，但是当功率超过一定阈值时，不会有显著效果。 给定SNR，具有较高比特传输率的调制技术将具有较高的BER。 物理层调制技术的动态选择能用于适配对信道条件的调制技术。 CDMA 码分多址，多址技术的一种，用于一个基站同多个用户传输数据。 时分多址TDMA：也是一种多址技术，将时间分为不同的时间片，每个时间片与一个用户通信。（GSM中使用） 频分多址FDMA：按照频率的不同与多个用户通信。 CDMA比方： 让聚会的客人使用多种语言谈论，人们实际上非常善于锁定他们能听懂的语言，而过滤其他的谈话。 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:2:0","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.3 WI-FI：802.11 无线LAN ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:3:0","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.3.1 协议及信道与关联 WI-FI协议簇下有几套不同的标准。它们都适用相同的媒体访问协议CSMA/CA、链路层帧使用相同的帧结构、向后兼容（旧设备可以支持新协议）。 2.4GHz：2.4～2.458GHz频段，无须执照的频道 5GHz：5.1～5.8GHz频段 安装一个AP时，需要分配一个SSID和一个信道号。 SSID：一个AP的服务集标志符号，代表着不同的WI-FI信号。 信道号：在一个频段范围内，不同的信道（2.4GHz频段内就有11个信道，其中有部分是重叠的，仅当两个信道相互隔着4个其他信道时，才叫非重叠的。比如1、6、11信道就是非重叠的） 无线主机加入AP： 被动扫描：802.11标准规定每个AP要周期性的发送信标帧，每个信标帧包括该AP的SSID和MAC地址。 主动扫描：通过向无线主机范围内所有的AP发送广播探测帧，AP会响应该探测帧。 一旦主机连接上一个AP，通过DHCP协议获取了一个AP的子网IP。 AP也可以要求主机鉴权： ​ 基于MAC地址 ​ 基于用户名和口令 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:3:1","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.3.3 802.11 帧 有效载荷:承载数据，IP数据报或者ARP分组等。允许的最大长度为2312字节，但是通常小于1500字节。 CRC：循环冗余校验 地址字段：包含4个MAC地址 序号、持续期和帧控制字段：序号用于使接收方区分新传输的帧和以前帧的重传；持续期包括了节点预约信道的持续期； ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:3:2","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.3.5 802.11 中的高级特色 速率适应 实现了一种具有速率自适应能力，该能力自适应地根据当前和近期信道特点来选择下面的物理层调制技术。 如果一个节点连续发送两个帧而没有收到确认（信道上一个比特差错的隐式指示），该传输速率降低到前一个较低的速率。 如果 10个帧连续得到确认，或如果用来跟踪自上次降速以来时间的定时器超时，该传输速率提高到上一个较高的速率。 功率管理 功率是移动设备的宝贵资源。 一个节点能够明显地在睡眠和唤醒状态之间交替 通过将802. 11帧首部的功率管理比特设置为1,某节点向接入点指示它将打算睡眠。 对于睡眠状态的主机，AP先缓存帧，待以后传输。 每次睡眠时主机设置一个定时器，在下次AP发送信标帧前，恰好唤醒主机。 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:3:3","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.3.6 个人域网络：蓝牙和ZigBee IEEE 802.15.1网络以低功率和低成本在小范围内运行,本质上是一个低功率、小范围、低速率的“电缆替代”技术，用于计算机与其无线键盘、鼠标或其他外部设备如蜂窝电话、扬声器、头戴式耳机及其他设备的互联。 802.15.1网络是自组织网络：不需要网络基础设施（如一个接入点）来互连802.15.1设备。 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:3:4","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.4 蜂窝英特网接入 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:4:0","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.4.1 蜂窝网体系结构概述 GSM:全球移动通信系统,也就是1G、2G、3G、4G、5G等技术。第一代（1G）系统是模拟FDMA系统，专门用于语音通信；初始的2G系统也是为语音而设计，但后来除了语音服务外还扩展了对数据（即因特网）的支持（2.5G）；3G系统也支持语音和数据，但更为强调数据能力和更高速的无线电接入链路；4G系统基于LTE技术，其特征为全IP核心网络，并且以几兆比特速率提供了话音和数据集成。 2G蜂窝网体系结构：语音与电话网连接 2G蜂窝系统的GSM标准对空中接口使用了组合的FDM/TDM（无线电）。在组合的FDM/TDM系统中，信道被划分为若干频率子带；对于每个子带，时间又被划分为帧和时隙。因此，对于一个组合的FDM/TDM系统，如果信道被划分为F个子带，并且时间被划分为T个时隙，那么该信道将能够支持F乘T个并发的呼叫。 一个GSM网络的基站控制器（Base Station Controller, BSC）通常服务于几十个收发基站。BSC的责任是为移动用户分配BTS无线信道，执行寻呼（paging）（找出某移动用户所在的小区），执行移动用户的切换。 在用户鉴别和账户管理（决定是否允许某个移动设备与蜂窝网络连接）以及呼叫建立和切换中，移动交换中心（Mobile switching Center, MSC）起着 决定性的作用。单个MSC通常将包含多达5个BSC,因此每个MSC有大约200000个用户。一个蜂窝提供商的网络将有若干MSC,使用称为网关MSC的特殊MSC将提供商的蜂窝网络与更大的公共电话网相连。 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:4:1","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.4.2 3G蜂窝数据网：将因特网扩展到蜂窝用户 3G数据服务设计者在不触动现有的核心GSM蜂窝语音网络的前提下，增加了平行的蜂窝数据网络。 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:4:2","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.4.3 走向4G：LTE 4G相比3G有两个重要的创新：一个全IP核心网和一个加强的无线电接入网。 4G系统体系结构：一个全IP核心网 一种统一的、全IP网络体系结构：语音通话服务和数据服务都承载在统一的IP服务中。 4G数据平面与4G控制平面的清晰分离。 LTE无线电接入网 LTE在下行信道采用频分复用和时分复用结合的方法，称之为正交频分复用（OFDM）。在LTE中，每个活跃的移动节点都可以在一个或更多个信道频率上被分配一个或更多个0.5ms时隙。通过分配越来越多的时隙（无论是用相同的频率还是用不同的频率），移动节点能够获取越来越高的传输速率。在移动节点之间进行时隙（重）分配的频度为每毫秒一次。不同的调制方案也能用于改变传输速率。 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:4:3","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.5 移动管理：原理 宽泛地讲，移动节点是随时间改变它与网络连接位置的节点。 从网络层角度看，移动用户存在以下几个移动情形： 然而，最好让移动节点的地址始终保持不变。如果一个移动实体在移动过程中能够保持其IP地址不变，从应用的角度，移动性就变得不可见。即应用程序不必关心IP地址潜在的变化，并且同样的应用程序代码既可用于移动连接，又可用于非移动连接。 如何维持移动用户在移动过程中保持不变的IP地址呢？ 一个类比的例子：一位20岁左右的青年从家里搬出，成为流动的人, 在一些宿舍或公寓居住，并经常改换住址。如果一个老朋友想与他联系，这位朋友怎样才能找到这个流动的朋友呢？一种常用的方法是与他的家庭取得联系，因为一位流动的青年通常会将其目前的地址告诉家里(即使没有其他原因，哪怕只是为了让父母寄钱来帮他付房租)。其家庭由于有一个永久地址，因此成为其他想与该流动青年联系的人可 采用的第一步。这些朋友后来与他的通信也许是间接的(如先将邮件发送到其父母家, 再转发给该流动的青年)，也许是直接的(如该朋友用得到的地址直接将邮件发送给其流动的朋友)。 实际： 在一个网络环境中，一个移动节点(如一台便携机或智能手机)的永久居所被称为归属网络(home network),在归属网络中代表移动节点执行下面讨论的移动管理功能的实体叫归属代理(home agent)。移动节点当前所在网络叫作外部网络(foreign network)或被访网络(visited network),在外部网络中帮助移动节点做移动管理功能的实体称为外部代理(foreign agent)。 外部代理的作用之一就是为移动节点创建一个所谓的转交地址（Care-Of Address, COA）,该COA的网络部分与外部网络的网络部分相匹配。因此一个移动节点可与两个地址相关联，即其永久地址（permanent address）（类比于流动青年的家庭地址）与其COA,该COA有时又称为外部地址（foreign address）（类比于流动青年当前居住的房屋地址）。 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:5:0","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.5.2 路由选择到移动节点 1. 移动节点的间接路有选择（目前所应用的） 归属代理的工作： 负责与外部代理交互以跟踪移动节点的COA。 监视到达的数据报，如果这些数据报寻址的节点的归属网络与该归属代理所在网络相同，但这些节点当前却在某个外部网络中。归属代理截获这些数据报，然后封装并转发它们。 在转发过程，为了维持数据包的原样，归属代理将通信者的原始完整数据报封装（encapsulate）在一个新的（较大的）数据报中。该COA的外部代理将接收并拆封该数据报，即从较大的封装数据报中取岀通信者的原始数据报，然后再向移动节点转发该原始数据报。 涉及到的协议： 移动节点到外部代理的协议。当移动节点连接到外部网络时，它向外部代理注册。类似地，当一个移动节点离开该外部网络时，它将向外部代理取消注册。 外部代理到归属代理的注册协议。外部代理将向归属代理注册移动节点的C0A。当某移动节点离开其网络时，外部代理不需要显式地注销C0A,因为当移动节点移动到一个新网络时，随之而来就要注册一个新的C0A,这将完成了注销。 归属代理数据报封装协议。将通信者的原始数据报封装在一个目的地址为C0A的数据报内，并转发之。 外部代理拆封协议。从封装好的数据报中取出通信者的原始数据报，然后再将该原始数据报转发给移动节点。 2. 移动节点的直接路由选择 间接路由选择存在的问题：三角路由选择问题，即使在通信者与移动节点之间存在一条更有效的路由，发往移动节点的数据报也要先发给归属代理，然后再发送到外部网络。 在直接路由选择方法中，通信者所在网络中的一个通信者代理(correspondent agent)先知道该移动节点的C0A。通信者代理然后将数据报直接通过隧道技术发往移动节点的COA。 虽然解决的三角路由选择问题，但引入了两个其他挑战： 需要一个移动用户定位协议（mobile-user location protocol）,以便通信者代理向归属代理查询获得移动节点的COA。 当移动节点从一个外部网络移到另一个外部网络时，如何将数据报转发到新的外部网络。 引入锚外部节点解决该问题。 ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:5:1","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["笔记"],"content":"7.6 移动IP 支持移动性的因特网体系结构与协议合起来称为移动IP。移动IP体系结构包含了许多我们前面考虑过的要素，包括归属代理、外部代理、转交地址和封装/拆封等概念。当前的标准［RFC 5944］规定到移动节点使用间接路由选择的方法。 移动IP标准由三部分组成： 代理发现。移动IP定义了一个归属代理或外部代理用来向移动节点通告其服务的协议，以及移动节点请求一个外部代理或归属代理的服务所使用的协议。 向归属代理注册。移动IP定义了移动节点和/或外部代理向一个移动节点的归属代理注册或注销COA所使用的协议。 数据报的间接路由选择。该标准也定义了数据报被一个归属代理转发给移动节点的方式，包括转发数据报使用的规则、处理差错情况的规则和几种不同的封装形式. ","date":"2021-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/:6:0","tags":["计算机网络"],"title":"计算机网络: 无线网络和移动网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"categories":["阅读"],"content":"摘抄 各式各样的社会关系也使他们结成小集团。出生于一省一县，是为“乡谊”，同一年考中举人或进士，是为“年谊”。同年的举人或进士就像学校里的同班一样，在原则上有彼此关照的义务，他们的考官则不消说是终身的恩师。婚姻关系，包括男女双方的远亲近属，是为“姻谊”。这多种的“谊”是形成文官派系的一个主要原因 申时行没有忽略文官的双重性格：即虽称公仆，实系主人；有阳则有阴。他必须恰如其分地处理此中矛盾 各式各样的社会关系也使他们结成小集团。出生于一省一县，是为“乡谊”，同一年考中举人或进士，是为“年谊”。同年的举人或进士就像学校里的同班一样，在原则上有彼此关照的义务，他们的考官则不消说是终身的恩师。多种的“谊”是形成文官派系的一个主要原因。 个人的私心会随时随地变迁，只有伦理道德永恒不变。 万历的看法是，邹元标和其他诤谏者并非对他尽忠，而是出于自私自利，即所谓“讪君卖直”。这些人把正直当作商品，甚至不惜用诽谤讪议人君的方法作本钱，然后招摇贩卖他正直的声望。 “首鼠两端”，即遇事左顾右盼缺乏决心。 申时行生平不愿宣扬别人的缺点，对于提拔自己的人，更不会妄加批判。他只是从这悲剧的内幕中得到了教益 在下层行政单位间许多实际问题尚未解决以前，行政效率的增进，必然是缓慢的、有限度的 如入火聚，得清凉门。”即能在狂燎烈焰之中有冰凝水静的感觉 利用这些小事可以促使公众注意，引起文官参加，假以时日，使小事积累而成大事，细微末节的局部问题转化而成为整个道德问题。在程序上讲，发展中的步伐则须前后衔接，第一步没有收到效果之前决不轻率采取第二步 而且出场交锋的人物起先总是无名小卒，直到时机成熟才有大将出马。这种方式，大凡久在政治圈子里的人物，都已看透，他们可以从青萍之末，预测大风暴的来临。 别人也和他一样，一身而具有“阴”、“阳”的两重性。有“阳”则有“阴”，既有道德伦理，就有私心贪欲。这种“阴”也决非人世间的力量所能加以消灭的。 他可以把他不喜欢的官员革职查办，但是很难升迁拔擢他所喜欢的官员 皇位是一种社会制度，他朱翊钧却是一个有血有肉的个人。一登皇位，他的全部言行都要符合道德的规范，但是道德规范的解释却分属于文官。他不被允许能和他的臣僚一样，在阳之外另外存在着阴。他之被拘束是无限的，任何个性的表露都有可能被指责为逾越道德规范。 他欣赏自己“从中调剂，就事匡维”这一处世和执政的原则，对待皇帝的办法则是“显谏者不若潜移为妙”，因为这种办法既对皇帝的权威无损，而臣下的目的又可以达到，这比之于臣下在奏章上奚落昏庸的皇帝，而皇帝用荆条痛打犯上的群臣总要高明得多。 由于成宪的不可更改，一个年轻皇帝没有能把自己的创造能力在政治生活中充分使用，他的个性也无从发挥，反而被半信半疑地引导进这乌有之乡，充当了活着的祖宗 他朱翊钧生前有九五之尊，死后被称为神宗显皇帝，而几百年之后他带给人们最强烈的印象，仍然是命运的残酷。 个人而对抗强大的社会力量，加之在具体处理这些诉讼的时候又过于自信，师心自用既没有对地方上的情形作过周密的考察，也没有宣布法律的准则，更没有建立专门的机构去调查案情、听取申辩以作出公正的裁决，海瑞的不能成功已不待言而自明 提出辞职的奏疏中他痛斥“举朝之士，皆妇人也”。这种一概骂倒的狷介之气，使他在文官集团中失去了普遍的同情。 地方官所关心的是他们的考成，而考成的主要标准乃是田赋之能否按时如额缴解、社会秩序之能否清平安定。扶植私人商业的发展，则照例不在他们的职责范围之内。何况商业的发展，如照资本主义的产权法，必须承认私人财产的绝对性。这绝对性超过传统的道德观念。 在我们这个古老的礼义之邦里，绝大多数的农民实际上早被列为顽民愚氓，不在文化教养之内，即使在模范官员海瑞的笔下，这些乡民也似乎只是一群动物，既浑浑噩噩，又狠毒狡诈，易于冲动。日常生活中为小事而发生口角已属司空见惯，打架斗殴以致死伤也时有发生。纠纷的一方有时还愤而自杀以倾陷仇家；即或由于病死，家属也总要千方百计归之于被殴打致死。 也许是有鉴于唐朝藩镇的跋扈，本朝从洪武开始，就具有这重文轻武的趋向。大约经过了一百年，文官集团进入了成熟的阶段，他们的社会地位上升到历史上的最高点，换句话说，也就是武官的社会地位下降到历史上的最低点。这种畸形的出现，原因在于本朝的政治组织为一元化，一元化的思想基础则是两千年来的孔孟之道。如果让军队保持独立的、严格的组织，和文官集团分庭抗礼，这一元化的统治就不可能如所预期地成长、发展，以至于登峰造极。这种制度既经固定，将领们即使出生入死屡建奇功，其社会影响也未必抵得上一篇精彩的大块文章。 然则严峻的纪律，仅是治军方针的一面；另一方面则必须鼓舞士气。士兵的自尊心和自信心在这里起着重要的作用。一支经常被敌人打得落花流水的部队谈不上自尊和自信，必胜的信念有赖于能力和技术，而能力和技术又来自平时的刻苦训练。 当局者才觉悟到一次战斗的成败并非完全决定于个人武艺。戚继光在训练这支新军的时候，除了要求士兵娴熟技术以外，就充分注意到了小部队中各种武器的协同配合，预定的战术取得成功，全靠各个士兵分工合作，很少有个人突出的机会。正由于如此，主将戚继光才不惮其烦地再三申明全队人员密切配合的重要性，并以一体赏罚来作纪律上的保证 然而我们这个庞大的帝国，在本质上无非是数不清的农村合并成的一个集合体，礼仪和道德代替了法律，对于违法的行为作掩饰则被认为忠厚识大体，各个机构之间的联系，从来没有可资遵守的成文条例。 未来的好几个世纪之内，上面这些情况在我们这个以农业经济为基础的国家里竟不能发生根本的改变。现代化的技术和古老的社会组织断然不能相容，要不是新的技术推动社会组织趋于精确和严密，那就是松散的社会组织扼杀新的技术，二者必居其一。 属脸色白晰、眼神轻灵、动作轻快的人一概摈诸门外，因为这种人几乎全是来自城市的无业游民，实属害群之马，一旦交锋，不仅自己会临阵脱逃，还会唆使周围的人一起逃跑，以便一旦受到审判时可以嫁祸于这些言辞钝拙的伙伴。 中国的古典诗歌，如果用冲淡自然的语言表现出深切或激动的情绪，就谓之含蓄；如果用棱角分明的粗线条勾画出不受拘束的气概，则谓之豪放 在平常的谈话中，他可以随口引用儒家的经典和史书上的教训，以此，文官们对他刮目相看，认为他不是樊哙式的武人。等到他的官阶越来越高，就有更多的文官把他引为同类，在一起饮酒赋诗，往来酬对。 总兵戚继光坦率地指出，北方的军官，“自将领而下，十无一二能辨鲁鱼”。将领如此，士兵的文化水准更可以想见。要是主将不用宗教迷信的因果报应作为规劝，还有什么其他办法辅助军事教育？ 传统的政治已经凝固，类似宗教改革或者文艺复兴的新生命无法在这样的环境中孕育。社会环境把个人理智上的自由压缩在极小的限度之内，人的廉洁和诚信，也只能长为灌木，不能形成丛林。 我们的帝国不是一个纯粹的“关闭着的社会”—在那样的社会里，各种职业基本上出于世代相承。—然而它所给予人们选择职业的自由仍然是不多的。一个农民家庭如果企图生活稳定，并且获得社会声望，惟一的道路是读书做官。然而这条道路漫漫修远，很难只由一个人或一代人的努力就能达到目的。通常的方式是一家之内创业的祖先不断地劳作，自奉俭约，积铢累寸，首先巩固自己耕地的所有权，然后获得别人耕地的抵押权，由此而逐步上升为地主。这一过程常常需要几代的时间。经济条件初步具备，子孙就得到了受教育的机会。这其中，母亲和妻子的自我牺牲，在多数情形之下也为必不可少。这种经过多年的奋斗而取得的荣誉，接受者只是一个人或至多几个人，但其基础则为全体家庭。因此，荣誉的获得者必须对家庭负有道义上的全部责任，保持休戚与共的集体观念。 “舟中多带柴米” 他们之所以能和睦相处，不在于耿定理学术理论上的弹性，而在于他性格的柔和轻松。他经常以禅宗式的机锋，避开辩论中的正面冲突，而以表面上毫不相关的语言，来表示自己的意见，使辩论的对手在思索之后被迫折服，因为他认为自己所掌握的真理，基于识见渊博；如果坚持片面的执拗，就等于放弃了宽阔的胸襟。因此，当耿定理在世之日，总是能够用他特有的方式调解他长兄和李贽之间的冲突。 ","date":"2021-12-16","objectID":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/:1:0","tags":["万历十五年","读书"],"title":"万历十五年摘抄与读后感","uri":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["阅读"],"content":"读后感 这本书以万历十五年前后发生的一系列事情为引子，很深刻的揭示了明朝整个官僚社会制度、文官集团内部真实的结构、由来等等。 ","date":"2021-12-16","objectID":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/:2:0","tags":["万历十五年","读书"],"title":"万历十五年摘抄与读后感","uri":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["阅读"],"content":"皇帝的权利和自由 在我的印象里，皇帝作为一国之主，掌握无限的权利，是自由自在的，他想干什么就干什么。如果有人对他指指点点，他完全可以惩罚甚至杀了此人。但是实际上，皇帝的自由程度甚至不如一个普通人。为何？ 皇帝需要参加各种活动，比如苛刻的早朝、祭祀活动、听各种讲座等等，如果任性不参加，就会有臣子站出来不厌其烦的说皇帝的不是，如果皇帝惩罚了这一个人，那就相当于捅了马蜂窝，从芝麻小官到朝廷重臣，不断有人跳出来说你，你烦不烦？这些官员为什么不怕惩罚（杖刑到发配边疆）？一个深刻原因是儒家文化，儒家文化用各种仁义道德来限制人，官员批评君主在表面上是要将君主拉回正道，舍身取义即使受到惩罚也无所谓，实质上这是一种“讪君卖直”的行为，也就是批评君主来赚取自己的名声，赢得其他官员的敬佩和夸奖，在日后又可能会因此被召回重用，并且历史上已经发生了无数次这样的例子来验证其有效性。实际上，这些官员里有大部分做官都是想贪污捞钱的。 皇帝的生活作风也不能过于昏乱，因为也会有臣子各种批评你；皇帝是不可以随心所欲册立哪个儿子为太子的，必须是长子，并且这一点是极其敏感的，无论皇帝有多么喜欢其他儿子，他都不能这么做，因为文官们会以儒家文化的名义（长子继承制）来说你，实际上，册立太子会影像文官集团内部利益，因为涉及到他们下一个“主子”的问题，历史上发生过太多站队没站对，等新一任君主上任后杀光所有站错队的官员事了。 所以皇帝实际上是一个傀儡，国家真正的主人是整个文官集团，他们控制着整个社会的稳定，整个国家的大事小事，维持着他们内部的利益。流水的皇帝，铁打的官僚集团。 ","date":"2021-12-16","objectID":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/:2:1","tags":["万历十五年","读书"],"title":"万历十五年摘抄与读后感","uri":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["阅读"],"content":"儒家文化 儒家文化是一把双刃剑。它以最高要以团结了整个文官集团，让官员评价和处理一些事情时，总是以儒家的仁义为标准，不考虑实际情况，一味的守旧，照成整个国家效率低下，发展不起来，不重视商业的发展，照成国家的慢慢落后。 然而，中国幅员辽阔，从中央到地方，面临着一系列问题，比如法律制度不完善、交通不顺、信息传递慢等等。要维持这么大国土的治安初步稳定，整个国家步调统一，是很困难很困难的。能做到这些，儒家文化起了很大的作用，最小一级的村和部落，是由族中有声望的长老来维持整个部落的秩序；往大一点到县级，由县一级的文官机构来维持秩序；最后到中央，他们都借助统一的儒家文化的约束和要求来做到步调一致，在很多地方没有产生矛盾。所以，在这一点上，儒家文化是起着积极作用的。 ","date":"2021-12-16","objectID":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/:2:2","tags":["万历十五年","读书"],"title":"万历十五年摘抄与读后感","uri":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["阅读"],"content":"启示 有很多事情，不能只看到表面，要看到本质。 未完待续… ","date":"2021-12-16","objectID":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/:2:3","tags":["万历十五年","读书"],"title":"万历十五年摘抄与读后感","uri":"/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E6%91%98%E6%8A%84%E4%B8%8E%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["笔记"],"content":"3 基础数据类型 虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。进一步将这些数组织在一起，就可表达更多的对象。 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.1 整型 基础类型 有符号： int8、int16、int32、int64四种 无符号： uint8、uint16、uint32、uint64四种 rune：对应int32，表示一个Unicode码点。这两个名称可以互换使用 byte：是uint8类型的等价类型，强调数值是一个原始的数据而不是一个小的整数。 int：32位操作系统—int32、64位操作系统—int64 uintptr:一种无符号的整数类型,没有指定具体的bit大小但是足以容纳指针. 类型转换 算术和逻辑运算的二元操作中必须是相同的类型，所以int32和int64不能直接相加减。 显示类型转换： var compote = int(apples) + int(oranges) 对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度。 浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.2 浮点数 Go语言提供了两种精度的浮点数，float32和float64。 float32 1.4e-45～3.4e38； 精度到6个十进制位 float64: 4.9e-324～1.8e308 精度到15个十进制位 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.3 复数 Go语言提供了两种精度的复数类型：complex64和complex128。 内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部： var x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.Println(x*y) // \"(-5+10i)\" fmt.Println(real(x*y)) // \"-5\" fmt.Println(imag(x*y)) // \"10\" //也可以如下定义 x := 1 + 2i y := 3 + 4i 复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.4 布尔型 一个布尔类型的值只有两种：true和false。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.5 字符串 一个字符串是一个不可改变的字节序列。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。 内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i\u003c len(s)条件约束。 s := \"你好\" fmt.Println(len(s)) // 6 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变；但是可以给一个字符串变量分配一个新字符串值。 s := \"你好\" fmt.Println(\"开始: %d\\n\", len(s)) //6 t := \"不好？\" s = t fmt.Println(\"后来: %d\\n\", len(s)) //9 不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.5.1 字符串字面值 Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。 常用转义字符： ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:1","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.5.2 Unicode Unicode收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点， Unicode码点对应Go语言中的rune整数类型。 我们可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样的大小32bit来表示。此方式简单统一，但是会浪费很多存储空间。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:2","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.5.3 UTF-8 UTF8是一个将Unicode码点编码为字节序列的变长编码。现在已经是Unicode的标准。 UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于 表示总共有多少编码个字节。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符 每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。 Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。 s := \"你好，不好也好\" b := []byte(s) // [228 189 160 229 165 189 239 188 140 228 184 141 229 165 189 228 185 159 229 165 189] s2 := string(b) // \"你好，不好也好\" ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:3","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.6 常量 常量表达式的值在编译期计算，而不是在运行期。 每种常量的潜在类型都是基础类型：boolean、string 或数字。 常量声明 const pi = 3.14159 const ( e = 2.71828182845904523536028747135266249775724709369995957496696763 pi = 3.14159265358979323846264338327950288419716939937510582097494459 ) ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:6:0","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.6.1 iota常量生成器 在一个常量声明语句块中，每写一个语句，都会自增1。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:6:1","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"3.6.2 无类型常量 有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类 型的字符、无类型的浮点数、无类型的复数、无类型的字符串。 通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的 表达式而不需要显式的类型转换。 ","date":"2021-12-02","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:6:2","tags":["Go"],"title":"Go语言基础—3.基础数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"2.1 命名 命名规则： 字母和下划线开头，后可以接任何数量的字母、数字或下划线（区分大小写）。 不能使用go关键字来命名。 不推荐使用go预定义名字命名。 习惯用驼峰命名法。 可见性： 在函数内定义，仅函数可用。 在函数外定义，包级可用。 循环体的变量仅循环内可用。 名字开头的大小写决定了是否是导出型（外部是否可以访问） fmt.Printf() ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:1:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.2 声明 声明语句定义了程序的各种实体对象以及部分或全部的属性。主要有4种类型的声明语句： var：变量 const：常量 type：类型 func：函数 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:2:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.3 变量 声明变量的一般语法： var 变量名 类型 = 表达式 其中，类型和= 表达式两者可省略其一。编译器会自动推断变量的类型或者初始值。 各个类型的0值： 整型类型0值为0 布尔类型为false 字符串为\"\" 接口或引用类型（slice、map、chan、函数）变量对应nil 数组或结构体等聚合类型对应的0值为每个元素或字段对应的0值 包级变量在main函数执行之前完成初始化，局部变量在声明语句被执行到时完成初始化。 var i,j,k int var b,f,s = true,2.3,\"foo\" var f,err = os.Open(name) ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.3.1 简短变量声明 变量名 := 表达式 i := 0 i,j := 0,1 //声明+（可能赋值） i,j = j,i //赋值 左边为单个变量： 该变量必须为首次声明，语句即起到声明+初始化的作用。 左边为多个变量： 左边至少要有一个是首次声明的变量，对于该变量—声明+初始化；对于其他变量—仅仅赋值。 i := 0 i ++ i,j:= 2,3 j++  ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:1","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.3.2 指针 go中的指针对C语言中指针类型进行了一定的限制，使其变得更加安全。 指针的值和类型： 一个指针的值对应着一个变量在内存中的地址。 一个指针的类型对应其值对应的内存地址中存储的元素类型。 var x int addr := \u0026x  那么addr的类型为*int，addr被称为“指向int类型的指针”，保存了x变量的内存地址。 指针运算符： \u0026x:取地址操作 *addr:取值操作 优先级很高，高于自增、自减语句 i := 0 i++ t := \u0026i fmt.Println(i, t)//1 0x140000140a0 fmt.Println(*t)//1 fmt.Println(\u0026*t)//0x140000140a0 fmt.Println(*\u0026*t)//1  指针类型的0值为nil。 指针之间也可以比较，当取值（地址）相同或者全部为nil时，才相等。 var x, y int fmt.Println(\u0026x == \u0026x, \u0026x == \u0026y, \u0026x == nil) // \"true false false\" go语言中局部变量的地址也是安全的： var p = f() func f() *int { v := 1 return \u0026v } ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:2","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.3.3 new函数 另一个创建变量的方法是调用用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 p := new(int) // p, *int 类型, 指向匿名的 int 变量 fmt.Println(*p) // \"0\" *p = 2 // 设置 int 匿名变量的值为 2 fmt.Println(*p) // \"2\" ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:3","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.3.4 变量的生命周期 变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。 包一级声明的变量:生命周期和整个程序的运行周期是一致的。 局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:3:4","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.4 赋值 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:4:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.4.1 元组赋值 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。 x, y = y, x a[i], a[j] = a[j], a[i] ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:4:1","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.4.2 可赋值性 在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。 目前来说的规则： 赋值要求类型必须完全匹配； nil可以赋值给任何指针或引用类型的变量。 常量有更加灵活的赋值规则。 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:4:2","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.5 类型 变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。 类型声明语句： type 类型名字 底层类型 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用。目前中文汉字作为不能导出的类型。 package tempconv import \"fmt\" type Celsius float64 // 摄氏温度 type Fahrenheit float64 // 华氏温度 const ( AbsoluteZeroC Celsius = -273.15 // 绝对零度  FreezingC Celsius = 0 // 结冰点温度  BoilingC Celsius = 100 // 沸水温度 ) func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) } 为什么要像上述代码自定义类型： 为了语义上的考虑，虽然Celsius，Fahrenheit都是float64类型，但是其语义不同，刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误； 一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型。 命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。 比较运算符==和\u003c也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型 的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较： var c Celsius var f Fahrenheit fmt.Println(c == 0) // \"true\" fmt.Println(f \u003e= 0) // \"true\" fmt.Println(c == f) // compile error: type mismatch fmt.Println(c == Celsius(f)) // \"true\"! ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:5:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.7 作用域 作用域和生命周期： 声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。 一个变量的生命周期是指程序运行时变量存在（声明到被回收）的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。 作用域： 语法块内部声明的名字是无法被外部语法块访问的。 语法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧对应的语法块那样。 有一个语法块为整个源代码，称为全局语法块；然后是每个包的包语法决；每个for、if和switch语句的语法决；每个 switch或select的分支也有独立的语法决；当然也包括显式书写的语法块（花括弧包含的语句）。 内置的类型、函数和常量，比如int、len和true 等是在全局作用域的，因此可以在整个程序中直接使用。 包级声明的可以在一个包中的任何源文件中访问。 导入的包，只有当前go文件可用。 局部作用域仅局部可用。 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:6:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"2.8 包的概念 声明属于哪个包：package语句 go语言以包来组织代码，包类似其他语言中的库或者模块。每个包中可以包含多个xxx.go文件，这些go文件的命名没有要求。其内部第一行的packge xxx 代码规定了该文件归属于哪个包。 package main import { \"fmt\" \"math/rand\" \"time\" } var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) fmt.Println(math.pi) rand.Seed(time.Now().UnixNano()) } 对于应用程序（可以运行的程序）来说，必须要有一个main包，main包下可以包含若干个go文件，但是必须有且仅有一个go文件中包含一个main函数，作为程序的入口。 对于供其他人使用的模块(库)来说，可以没有main包。 导入包：import 语句 一个go文件中，以大写字母开头命名的函数称为可导出的函数，也就是可以给外界显示调用；以小写字母开头命名的函数称为不可导出的函数，外界无法调用。此规则适用于（变量、常量、函数、定义类型和类型别名）。 用import xxx导入一个包后，即可使用其中的资源，使用时需要加上包名xxx.funcA。 当没有导入需要用到的包或者导入了没有用到的包，go编译器都无法编译通过。 查找包 https://golang.org/pkg https://godoc.org/ 中可以找到标准库和社区写的包。 ","date":"2021-12-01","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:7:0","tags":["Go"],"title":"Go语言基础—2.程序结构","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["笔记"],"content":"链路层和局域网 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:0:0","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"6.1 链路层概述 在本章中，将运行链路层协议的任何设备称为节点，节点包括主机、路由器、交换机和wifi接入点。把沿着通信路径连接相邻的通信信道称为链路。 该数据报将实际通过6段链路：发送主机与WiFi接入点之间的WiFi链路，接入点和链路层交换机之间的以太网链路，链路层交换机与路由器之间的链路，两台路由器之间的链路，最后是交换机和服务器之间的以太网链路。在通过特定的链路时，传 输节点将数据报封装在链路层帧中，并将该帧传送到链路中。 注意到这3段运输是由不同的公司管理，使用了完全不同的运输方式（豪华大轿车、飞机和火车）。尽管运输方式不同，但它们都提供了将旅客从一个地点运输到相邻地点的基本服务。在这个运输类比中，一个游客好比一个数据报，每个运输区段好比一条链路，每种运输方式好比一种链路层协议，而该旅行社好比一个路由选择协议。 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:1:0","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"6.1.1 链路层提供的服务 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:1:1","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"6.4 交换局域网 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:0","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"6.4.1 链路层寻址和ARP 交换机运行在链路层，它们交换链路层帧，不识别网络层地址。 网络层和链路层都需要地址。 1. MAC地址 并不是主机或路由器具有链路层地址，是它们的适配器（网卡、网络接口）具有链路层地址。 MAC地址（LAN 地址、物理地址），长度为6字节，被设定为永久的（但是软件可以改变）。 IEEE管理着MAC地址的分配，网卡厂商生产网卡时，IEEE固定一个MAC地址的前24比特，后面毕业由厂商自己分配。 无论机器在何方，MAC地址总是不会变，不像IP地址具有层次结构，在不同的局域网，IP地址会改变。（MAC地址像身份证号，IP地址像邮政编码） 当某些适配器要向另一目的适配器发送一个帧，源适配器将包含目的适配器MAC地址插入到该帧中，发送到局域网。适配器接收到帧，与自己的MAC地址匹配，匹配上则接收，不匹配则丢弃。 当适配器想让局域网内所有适配器都接收一个帧，就插入一个特殊的MAC广播地址（48个1，FF- FF- FF- FF- FF- FF） 为什么既要MAC地址，又要IP地址？ IP地址工作在网络层，MAC地址工作在链路层。 局域网是为了任意网络层协议而设计的，不仅仅是IP和HTTP，如果适配器被分配为IP地址，而不是MAC地址，那么将不能方便的支持其他网络层协议。 如果适配器使用网络层地址，而不是MAC地址，那么适配器缓存必须存储IP地址，每次改变都要重新配置。 如果适配器不使用地址，IP数据报向上网络层传递，网络层根据数据报携带的目的地址匹配，那么对于每个帧，主机都将花费时间和资源去处理。 总而言之，不同的层需要它们自己的寻址方案，目前，我们看到有3种类型的地址：应用层的主机名、网络层的IP地址、链路层的MAC地址。 2. 地址解析协议ARP 地址解析协议：完成网络层IP地址和链路层MAC地址的转换，将IP地址解析为MAC地址（DNS将主机名解析为IP地址）。ARP只为在同一个子网上的主机和路由器解析IP地址。 ARP表： 每个主机和路由器在内存中都有一个ARP表，该表包含了IP地址到MAC地址的转换，每条记录都有一个生存时期（一般20分钟），ARP表不一定记录了局域网内所有主机IP和MAC的条目。 当ARP表中没有目的主机对应的MAC地址时： 源主机向适配器传递一个包含MAC广播地址的ARP查询分组 子网上所有的适配器都能接收该分组，并向上传递给其ARPmo模块 IP地址匹配的适配器会发送一个ARP响应分组 源主机更新其ARP表 查询ARP报文在广播帧中发送，响应ARP报文在标准帧中发送。 ARP表是即插即用的，自动建立，当主机与子网断开，其他主机内存中的ARP表最终也不会保留该主机的记录。 ARP表既包含网络层IP地址，也包含链路层MAC地址，所以该协议是跨链路层和网络层边界的协议。 发送数据报到子网以外 右上角主机A向右下角主机B发送数据。 A发送的数据报携带B的IP地址和路由器的MAC地址 路由器接收到数据报，更具其ARP表，转发携带B的IP地址和B的MAC地址的数据报 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:1","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"6.4.2 以太网 以太网是到目前为止最流行的有线局域网技术，而且到可能预见的将来它可能仍保持这一位置。 集线器： 工作在物理层，作用于比特而不是帧，当表示一个0或者1的一个比特到达一个接口，集线器重新生出这个比特，并将其能量强度放大，将该比特向其他所有接口传输出去。 因此，集线器下的是一个广播局域网。并且当同时收到两个接口发来的帧时，将发生碰撞，生出该帧的节点必须重传。 1. 以太网帧结构 ​ 数据(46~1500字节)：承载IP数据报。MTU（最大传输单元），一般为1500字节，如果IP数据报超过1500，主机必须将数据报分片；最小为46字节，如果小于46字节，数据报必须被填充到46字节（利用IP数据报中长度字节去除填充部分）。 目的地址(6字节)：目的适配器的MAC地址。当目的适配器收到一个以太网帧，当该帧中的目的地址是自身地址或者是广播地址时，该适配器将帧的数据字段内容传给网络层；当收到其他MAC地址的帧，丢弃之。 源地址(6字节)：包含了传输该帧到局域网上的适配器MAC地址。 类型字段(2字段)：指定了数据帧的不同网络层协议。 CRC(4字节)：循环冗余检测，使得接收适配器检测帧是否引入了差错。 前同步码(8字节)：前7个字节用于同步两个适配器的时钟；第8个字节提示重要的内容就要到了。 以太网技术向网络层提供服务的特点： 无连接服务：即发生前不需要事先握手。 不可靠：当CRC校验通过时，也不回送确认帧；没有通过时，简单丢弃。因此发生方根本不知道接收方是否正确收到了发送的帧（可靠服务由网络层的TCP来提供）。（因为简单，使用广泛） 2. 以太网技术 随着时代的发展，以太网演化出多种协议，如10BASE-T、 10BASE-2、100BASE-T、1000BASE-LX和10GBASE-T等。其命名的首部数字代表速率，base指基带以太网，后面的字母代表传输介质，双绞铜线、光纤等。 在演化过程中，初始的以太网MAC协议和帧格式被保留了下来。 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:2","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"6.4.3 链路层交换机 交换机的任务时接收入链路层帧，并将它们转发到出链路，交换机对于子网中的主机和路由器是透明的。 1 交换机转发和过滤 过滤（filtering）是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。 转发（forwarding）是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。 交换机表 交换机的过滤和转发借助交换机表完成。 交换机表包含某个局域网上某些主机和路由器的非全部的表项。如下 假定目的地址为DD-DD-DD-DD-DD-DD的 帧从交换机接口x到达。交换机用MAC地址DD-DD-DD-DD-DD-DD索引它的表。 如果找不到目的MAC地址，交换机则广播该帧。 如果有接口y的MAC地址和目的地址对应，直接转发。 2. 自学习 交换机的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。 换句话说，交换机是自学习（self-leaming） 的、即插即用的。 交换机初始表为空。 对于每个借口接收到每个帧，交换机记录其源MAC地址、到达的接口、当前时间。 在一段时间后（老化期），超时删除表项。 3. 链路层交换机的性质 不同于总线、集线器的星形拓扑结构，使用交换机有如下特点。 消除碰撞：不会因为碰撞而浪费带宽。 异质的链路：交换机将链路彼此隔离，局域网中不同的链路能够以不同的速率传输。 管理：能够检测到异常的适配器（持续发送帧、断开连接等），也可收集带宽使用的统计数据、碰撞率、和流量类型等。 4. 交换机和路由器的比较 同：路由器和交换机都是存储转发分组的交换机。 异：路由器是使用网络层地址转发分组的存储转发分组交换机。而交换机是用MAC地址转发的，交换机工作在链路层，路由器工作在网络层。 ​ 交换机优缺点： 即插即用 较高的速率过滤和转发分组 网络拓扑结构呈树形 大型交换机网络ARP表大 没有广播网络处理措施 路由器的优缺点： 没有生成树限制，有更丰富的拓扑结构 非即插即用，需要人为配置IP地址 每个分组处理时间比交换机长 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:3","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"6.4.4 虚拟局域网 虚拟局域网：VLAN，支持VLAN的交换机允许经一个单一的物理局域网 基础设施定义多个虚拟局域网。在一个VLAN内的主机彼此通信，仿佛它们（并且没有其他主机）与交换机连接。 如上图，电子工程系流量如何发送到计算机科学系呢？ 将一个端口（1）与外部路由器连接，并将该端口设置为同属于EE VLAN和CS VLAN，。从电子工程系发 往计算机科学系的数据报将首先跨越EE VLAN到达路由器，然后由该路由器转发跨越CS VLAN到达CS主机。 VLAN干线连接 每台交换机上的一个特殊端口（左侧交换机上的端口 16,右侧交换机上的端口 1）被配置为干线端口，以互联这两台VLAN交换机。 由标准以太网帧与加进首部的4字节VLAN标签（VLAN tag）组成，而VLAN 标承载着该帧所属的VLAN标识符。 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:2:4","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"6.6 数据中心网络 每个数据中心都容纳了数万至数十万台主机, 并且同时支持着很多不同的云应用（例如搜索、电子邮件、社交网络和电子商务）。每个数据中心都有自己的数据中心网络（data center network）,这些数据中心网络将其内部主机彼此互联并与因特网中的数据中心互联。 数据中心中的主机称为刀片（blade）,与比萨饼盒类似，一般是包括CPU、内存和磁盘存储的商 用主机。主机被堆叠在机架上，每个机架一般堆放20-40台刀片。在每一个机架顶部有一台交换机，这台交换机被形象地称为机架顶部（Top of Rack, TOR）交换机，它们与机架上的主机互联，并与数据中心中的其他交换机互联。具体来说，机架上的每台主机都有一块与TOR交换机连接的网卡，每台TOR交换机有额外的端口能够与其他TOR交换机连接。 数据中心网络设计是互联网络和协议设计的艺术，该艺术专注与机架彼此连接和与边界路由器相连接。 在数据中心内部, 外部请求首先被定向到一个负载均衡器（load balancer）。负载均衡器的任务是向主机分发 请求，以主机当前的负载作为函数来在主机之间均衡负载。 负载均衡器基于分组的目的端口号和目的IP地址做出决策，将客户的请求打到某一台主机。 主机处理完请求后，向负载均衡器回送响应，负载均衡器再将其中继给客户。 负载均衡器不仅平衡主机间的工作负载，还提供类似NAT的功能，将外部IP转换为内部IP，从而提供了安全性。 2. 等级体系结构 当主机规模扩张到几万台，数据中心通常应用路由器和交换机等级结构，并且还提供冗余链路，比如没太TOR交换机能够与2台第二层交换机连接等。 ","date":"2021-11-23","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/:3:0","tags":["计算机网络"],"title":"计算机网络：链路层和局域网","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["笔记"],"content":"网络层协议 ​ 控制平面作为一种网络范围的逻辑，不仅控制沿着从源主机到目的主机的端到端路径间的路由器如何转发数据报，而且控制网络层组件和服务如何配置和管理。 OSPF是一种运行在单一ISP的网络中的路由选择算法。BGP是一种在因特网中用于 互联所有网络的路由选择算法，因此常被称为因特网的“黏合剂” 。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["笔记"],"content":"5.2 路由选择算法 其目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径(等价于路由)。通常，一条好路径指具有最低开销的路径。 分类 根据该算法是集中式还是分散式 集中式路由选择算法：用完整的、全局性的网络知识计算岀从源到目的地之间的最低开销路径。 要求该算法在真正开始计算以前，要以某种方式获得这些信息。 具有全局状态信息的算法常被称作链路状态(Link State, LS) 算法。 分散式路由选择算法：没有节点拥有关于所有网络链路开销的完整信息。 相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后，通过迭 代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或 一组目的节点的最低开销路径。 根据算法是静态的还是动态 在静态路由选择算法(static routing algorithm)：路由随时间的变化非常缓慢，通常是人工进行调整(如人为手工编辑一条链路开销) 。 动态路由选择算法(dynamic routing algorithm) ：随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路开销的变化而运行。 根据它是负载敏感的还是负载迟钝的进行划分 负载敏感算法：链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该 拥塞链路来选择路由。 负载迟钝算法：某条链路的开销不明确反映当前或者最近的拥塞水平。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:1:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["笔记"],"content":"5.2.2 距离向量路由选择算法 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:1:1","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["笔记"],"content":"5.3 因特网中自治系统内部的路由选择:OSPF 上述讨论的LS（狄杰斯特拉）和距离向量路由选择协议都不能适用于整个网络，原因有如下两点： 网络规模。当今的因特网由数亿台主机组成。在这些主机中存储的路由选择信息显然需要巨大容量的内存。并且求出所有路由器之间的链路开销需要巨大的负担，并且距离向量算法可能永远无法收敛。 管理自治。因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器(如在自己的网络中运行它所选择的某种路由选择算法)，或对外部隐藏其网络的内部组织面貌。 自治系统（AS）：一个自治系统由其全局唯一的AS号(ASN)所标识。每个AS由一组通常处在相同管理控制下的路由器组成。 通常在一个ISP中的路由器以及互联它们的链路构成一个AS；也有某些ISP将网络划分为多个AS；也有一个一级ISP在整个网络使用一个庞大的AS，其他子ISP再进行划分为多个AS。 开放最短路优先(OSPF) OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。 使用OSPF, —台路由器构建了一幅关于整个自治系统的完整拓扑图(即一幅图)。于是, 每台路由器在本地运行Dijkstra的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。 各条链路开销是由网络管理员配置，管理员也许会选择将所有链路开销设为1,因而实现了最少跳数路由选择，或者可能会选择将链路权值按与链路容量成反比来设置，从而不鼓励流量使用低带宽链路。 使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时(如开销的变化或连接/中断状态的变化)，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地 (至少每隔30 min一次)广播链路状态 。 优点： 安全。路由器间的OSPF报文能够配置两类鉴别，即简单的和MD5的。使用简单的鉴别，每台路由器配置相同的口令。当一台路由器发送一个OSPF分组，它以明文方式包括了口令 。MD5的要对比报文携带的MD5散列和路由去计算出来的MD5值。 多条相同开销的路径。当到达某目的地的多条路径具有相同的开销时，OSPF允许使用多条路径。 对单播与多播路由选择的综合支持。 支持在单个AS中的层次结构。一个OSPF自治系统能够层次化地配置多个区域。 每个区域都运行自己的OSPF链路状态路由选择算法，区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。 区边界路由器：即在子区中，又在主干网络区中。“汇总” 到达所在区网络的距离, 通告给其他区边界路由器。 主干路由器( Backbone Routers):在主干区内运行OSPF路由算法。 AS边界路由器：连接其他AS。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:2:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["笔记"],"content":"5.4 ISP之间的路由选择：BGP BGP(Broder Bateway Protocal)：边界网关协议。 热土豆路由选择依据的思想 对于路由器lb,尽可能快地将分组送出其AS (更明 确地说，用可能的最低开销)，而不担心其AS外部到目的地的余下部分的开销。就 “热 土豆路由选择”名称而言，分组被类比为烫手的热土豆。因为它烫手，你要尽可能快地将它传给另一个人(另一个AS)。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:3:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["笔记"],"content":"5.6 ICMP：英特网控制报文协议 ICMP，被主机和路由器用来彼此沟通网络层的信息，典型的用途是差错报告。 例如HTTP会话中的“404 网络不可到达“等。 在某个位置，IP路由器不能找到一条通往HTTP请求中所指定的主机的路径，该路有趣就会向你的主机生成并发出一个ICMP报文以提示该错误。 ICMP报文是作为IP有效承载的，就像TCP和UDP报文段作为IP有效承载那样。ICMP有一个类型字段和一个编码字段，并且包含引起该IP数据报的首部和前8个字节。 Ping：ping程序发送一个ICMP类型8编码0的报文到指定主机，看到回显请求，目的主机发回一个类型0编码0的ICMP报文。 Traceroute:由ICMP报文实现。 源主机向目的主机发送一系列普通IP数据报，每个数据报包含一个不可到达的UDP端口号的UDP报文段 第一个数据报的TTL为1，第二个为2，以此类推 当第n个书记报到达第n台路由器，刚好过期，路由器丢弃该数据报，并发送一个ICMP警告报文给源主机（类型11，编码为0），该告警报文包含了路由器的名字和它的IP地址。 当目的主机收到报文时，由于端口不可到达，它向源主机发送一个端口不可到达的ICMP报文（类型3，编码3），当源主机接收到该报文，它就停止发送类似数据报。 ","date":"2021-11-17","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/:4:0","tags":["计算机网络"],"title":"计算机网络：网络层协议","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"categories":["笔记"],"content":"可靠数据传输协议原理 ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:0:0","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"构造可靠传输协议 可靠数据传输协议是由 检验和、序号、定时器、肯定和否定确认这几个机制来确保的。 其中检验和用于接收方判断分组是否发生错误，序号帮助发送方决定重新发送哪个分组，接收方发送肯定和否定确认告诉发送方是否正确接收到了分组。 将发送方称为S，接收方成为R，考虑以上几种情况： 一切正常 S向R发送0号分组，R收到了分组，利用检验和判断分组是否正确，如果正确，R向S发送一个0号分组的ACK确认分组，告诉S已经收到了正确分组。S再向R发送下一个分组1。 分组丢失 S向R发送0号分组，此时S的定时器开始计时，0号分组在传输过程中丢失，R没有收到任何数据，所以也没有向S发送任何确认信号。当计时器停止时，S向R在发送一个0号分组。 ACK丢失 S向R发送0号分组，并开启了定时器。R收到了分组，并回传一个ACK信号，但是信号在传输过程中丢失，当S的定时器停止时，S会再向R发送相同分组，此时R再次收到了相同的分组，开启冗余检测机制，会丢弃冗余的分组。 过早超时 S向R发送0号分组，并开启了定时器。R收到了分组，并回传一个ACK信号，但是信号在传输过程中超时，S又发了一个相同的分组给R，之后S收到该上一个分组ACK，但是它什么也不做。 ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:1:0","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"流水线可靠数据传输协议 如果采取“可靠数据传输协议”：接收一个分组，等待一个ACK到达后，再发送下一个分组的方式，发送发大部分时间都处于等待中，会带来有效吞吐量小，发送方利用率低的缺陷。 引入流水线技术有助于解决这种缺陷。即不以停等的方式运行，允许发送方发送多个分组而无须等待确认。 这样的技术提出如下几个要求： 增加序号的范围，每个分组必须有一个唯一的序号，有多个再输送中而未被确认的分组 发送方和接收方两端需要缓存多个分组。发送方最低限度要缓存那些已经发送但没有确认的分组。 解决流水线的差错恢复有两种基本方法：回退N步（go-back-N,GBN)、选择重传(Selective Repeat,SR) ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:2:0","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"GBN(回退N步) 窗口长度N由包括两部分（已发送但未被确认的分组和可用但是还没有发送的分组序号）组成。 一个分组的序号承载在分组首部的一个固定长度字段中规定，例如如果只分配1比特给这个字段，那么这个序号空间只能是0和1。 GBN的运行过程如下图： 发送方批量发送多个分组，并为每个已经发送的分组开启一个定时器，接收方按序接收分组，每接收到一个分组，发送一个ACK。 例如发送方批量发送了0—4号分组，其中3号分组丢失。 对于发送方：它的3号计时器到期后，就把3号及3号之后的分组再重新发送； 对于接收方：它收到了0、1、2号分组，每收到一个就发送该分组的ACK。由于未收到3号分组，它接收到4号分组后，把4号分组丢弃，再发送上一个正确分组的ACK，即2号ACK。直到接收到3号分组为止。 GBN协议允许发送方用多个分组填充流水线，因此避免了停等协议中的信道利用率问题，使用到了序号、累计确认、检验和、超时重传操作等技术。 ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:2:1","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"选择重传 GBN协议也存在一些性能问题，当窗口长度和传输时延过大时，单个分组的差错带来的大量不必要重传的分组再次重传。 选择重传协议通过让接收方缓存没有确认的分组以及维护一个窗口的方式，实现发送方仅仅重传接收方没有收到或者受损的分组。 分组重新排序问题： 分组重新排序的表现：一个具有序号或者确认号x的分组的旧副本可能突然出现。 当信道是一个网络时，分组重新排序是可能发生的，此时，网络相当于缓存了分组，并随时可能把分组释放出来。 解决： 确保一个序号不被重新使用，假定分组在网络中的存活时间最大为3分钟。 ","date":"2021-11-04","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/:2:2","tags":["计算机网络"],"title":"计算机网络：可靠数据传输协议原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"TCP是因特网运输层的面向连接的可靠的运输协议。依赖于差错检测、重传、累计确认、定时器以及带有序号和确认号的首部字段，使得它可以在不可靠的IP协议之上，提供可靠的运输协议。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:0","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["笔记"],"content":"3.5.1 TCP连接概述 TCP是面向连接的。这里的连接指的是一两条逻辑连接，其共同状态包括要维护的参数、TCP缓存等,仅仅保留在两个通信端系统的TCP程序中。 *TCP是点到点的。即单个发送方和单个接收方之间的连接，其中发送方被称为客户端，接收端被称为服务器。 *建立连接的过程：客户先发送一个特殊（首部字段特殊）的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后客户端再用第三个特殊报文段作为响应，前两个报文段不承载任何应用层数据。这样一个建立连接的过程称为三次握手。 一旦建立起TCP连接，两个应用进程旧可以相互发送数据。客户进程将数据通过套接字传给TCP，TCP将这些数据存入发送缓存，接下来再陆续从发送缓存里取出数据，封装送给网络层。 *MSS（Maximum Segment Size,最大报文长度）：报文段里应用层数据的最大长度，不包括首部字段。 *MTU（Maximum Transmission Unit,最大传输单元）：包含TCP首部的报文段最大长度，以太网和PPP链路层协议都有1500字节的MTU，一个典型值是1460。 TCP连接的组成：客户端主机上的缓存、变量与套接字；服务器主机上的缓存、变量与套接字。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:1","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["笔记"],"content":"3.5.2 TCP报文段结构 TCP的首部一般是20字节，比UDP首部多12字节。 源端口号和目的端口号：用于多路复用/分解 32比特的序号字段/32比特的确认号字段：用于实现可靠数据传输 16比特的接收窗口字段，用于流量控制 4比特首部长度字段：指示了TCP的首部长度 可选与变长的选项字段：用于连接双方协商最大报文长度（MSS） 6比特的标志字段： ACK：指示确认字段中的值是否有效 RST、SYN、FIN：用于连接的建立和断开。 CWR、ECE：拥塞明确。 PSH：数据是否立即交给上层。 URG：指示包含紧急数据。 序号和确认号 序号和确认号是TCP首部中最重要的两个字段。一个报文段的序号是报文段首字节的字节流编号。 假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0,第二个报文段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP 报文段首部的序号字段中。 确认号用于接收端向发送端发送已经接收到的正确顺序报文段中，序号最大的报文段。也就是主机正在等待的数据的下一个字节的序号 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:2","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["笔记"],"content":"3.5.3 往返时间的估计和超时 TCP采用超时/重传机制来处理报文段的丢失问题，那么如何设置超时间隔呢。 估计往返时间 RTT（SimpleRTT ）:某报文段被发出（交给IP）到对该报文的确认被收到之间的时间间隔。 由于路由器的拥塞，报文段的RTT会随时间波动，TCP维持一个RTT的均值（EstimatedRTT)，一旦获得一个新的R TT，TCP采用下列公式来更新EstimatedRTT： DevRTT ：RTT偏差，用于估算SampleRTT 一般会偏离EstimatedRTT的程度，RTT波动较小，则DevRTT值就很小。 设置和管理重传超时间隔 超时间隔被定义为上式，初始Timeoutinterval为1秒，当出现超时后，Timeoutinterval值将加倍，再次接收报文段后，再使用上式计算Timeoutinterval。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:3","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["笔记"],"content":"3.5.4 可靠数据传输 英特网网络层（IP服务）是不可靠的，IP服务的数据报可能会溢出路由器缓存而丢失；也可能是乱序到达；数据报中的比特还可能会损坏（0变成1）。 TCP在IP不可靠的尽力而为的服务上创建了一种可靠数据传输服务，确保一个进程从其接收缓存中读取的数据流是无损坏、无间隙、非冗余、按序的数据流。下图给出了TCP发送方的高度简化描述。 NextSeqNum和SendBase的差组成了窗口。 三种情况 确认丢失 超时重传 确认丢失，但是没有超时 超时间隔加倍 TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，一旦收到确认，就立马使用EstimatedRTT值与DevRTT值推算得到超时间隔。 这种设定有助于拥塞控制，防止链路中有太多的数据报。 快速重传 冗余ACK：发送方已经收到了对该报文的确认，接收方再次发送该报文的ACK。 一旦收到3个冗余ACK, TCP就执行快速重传。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:4","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["笔记"],"content":"3.5.5 流量控制 TCP收到连续的、正确的字节后，就将数据放入接收缓存，等待应用程序取出（并不是一到达立马取出）。 当数据过多时，就可能溢出缓存。因此TCP提供了流量控制服务，以消除发送方使接收方缓存溢出的可能性。 流量控制是一个速度匹配服务，即发送方的发送速率与接收方的应用程序读取速率相匹配。 TCP通过记录并发送缓存空闲空间的大小来实现流量控制 当rwnd等于0时，主机A作为发送方，继续发送只有一个字节的报文，这些报文段将会被接收方B确认，但B的缓存被清空后，确认报文里将包含一个非0的 rwnd值。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:5","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["笔记"],"content":"3.5.6 TCP连接管理 连接的建立 客户端发送SYN报文段。 客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段，该报文段不包含任何应用层数据，但是首部一个标志位（SYN）被设置为1。这个特殊报文段被称为SYN报文段。另外，客户会随机地选择一个初始序号（client-isn）,并将此编号放置于该起始的TCP的SYN 报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。 服务器回传SYNACK报文段。 当TCP的SYN报文段的IP数据报到达服务器主机，服务器从数据报中提取出TCP的SYN报文段，并为TCP连接分配TCP缓存和变量。并回送一个允许连接的报文段，这个报文段不包含任何应用层数据，首部的SYN字段也为1，确认号字段为client-isn+1 ，并选择自己的初始序号sever-isn，将其放到TCP首部的序号字段。含义：“我收到了你发起建立连接的SYN分组，该分组带有初始序号 clientjsno我同意建立该连接。我自己的初始序号是server-isn”。 连接建立。 在收到SYNACK后，客户端给给该连接分配缓存和变量。再发送一个报文段，在确认字段设置为server-isn + 1，并且SYN字段设置为0，该阶段的报文段可以携带客户到服务器的数据。连接建立后，后续报文段中的SYN字段都被置为0。 连接的终止 参与TCP连接的两方任意一方都可终止该连接。当连接结束后，主机中的缓存和变量都将被释放。 假设客户端打算关闭TCP连接。 客户向服务器发送一个特殊报文段，其FIN字段设置为1. 服务器接收到该报文段，回送一个确认报文段，然后也发送足迹的FIN为1的终止报文段 客户对这个报文段进行确认，随后两台主机上关于该连接的所有资源都被释放。 ","date":"2021-11-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/:0:6","tags":["计算机网络"],"title":"计算机网络: 面向连接的传输-TCP","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp/"},{"categories":["笔记"],"content":"conda常用命令 ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["笔记"],"content":"1. 管理conda 查看conda版本 conda --version 查看python版本 conda --python 进入/退出python环境 python quit() 更新conda版本 conda update conda ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["笔记"],"content":"2. 管理环境 创建一个环境 conda create --name python34 python=3.4 #创建一个名为python34的环境，指定python版本为3.4 切换环境 #windows activate python34 #mac/linux source activate python34 删除一个已有的环境 conda remove --name python34 --all 列出所有环境 conda info -e #conda info -envs 复制一个环境 conda create -n flowers --clone python34 ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["笔记"],"content":"3. 管理包 conda安装和管理python包非常方便，可以在指定的python环境中安装包，且自动安装所需要的依赖包，避免了很多拓展包冲突兼容问题。 不建议使用easy_install安装包。大部分包都可以使用conda安装，无法使用conda和anaconda.org安装的包可以通过pip命令安装 使用合适的源可以提升安装的速度 ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["笔记"],"content":"3.1 使用conda命令安装 查看该环境中已经安装的包 conda list 在指定环境中安装指定包 #1.直接指定 conda install --name python34 beautifulsoup4 #2. 进入指定环境再安装 source activate python34 #windou s系统去除 source ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["笔记"],"content":"3.2 从Anaconda.org安装一个包 如果一个包不能使用conda安装，我们接下来将在Anaconda.org网站查找。 在浏览器中，去 Anaconda资源官网。我们查找一个叫“bottleneck”的包，所以在左上角的叫“Search Anaconda Cloud”搜索框中输入“bottleneck”并点击search按钮。 Anaconda.org上会有超过一打的bottleneck包的版本可用，但是我们想要那个被下载最频繁的版本。所以你可以通过下载量来排序，通过点击Download栏。 点击包的名字来选择最常被下载的包。它会链接到Anaconda.org详情页显示下载的具体命令： conda install--channel https：//conda .anaconda.ort/pandas bottleneck ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:2","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["笔记"],"content":"3.3 pip命令安装 对于那些无法通过conda安装或者从Anaconda.org获得的包，我们通常可以用pip命令来安装包。 pip只是一个包管理器，所以它不能为你管理环境。pip甚至不能升级python，因为它不像conda一样把python当做包来处理。但是它可以安装一些conda安装不了的包。 可以上pypi网站查询要安装的包，查好以后输入pip install命令就可以安装这个包了。 我们激活想要放置程序的python环境，然后通过pip安装一个叫“See”的程序。 pip install see ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:3","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["笔记"],"content":"3.4 文件源码安装 如果真的遇到走投无路的境地，也就是上面这些方法通通不管用！！！那就只能下载源码安装了，比如exe文件（双击安装）或者whl文件（pip安装）等等。还有在github上找到源码，使用python setup.py install命令安装。 ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:4","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["笔记"],"content":"3.5 移除 移除一个包 conda remove -n beautifulsoup4 移除环境 conda remove -n python34 --all 移除conda #linux rm -rf ~/miniconda #或者 rm -rf ~/anaconda #或者 4. 频道管理 列出所有channel conda config --show channels #或者 conda config --get channels 追加channel conda config --append channels CHANNEL_NAME #并没有改变优先级 设定首要channle conda config add channels conda-forge #将此channel设定为第一优先级 删除channel conda config --remove channels NOT_WANTED 添加清华源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 源 #豆瓣 https://pypi.douban.com/simple/ #默认源 https://pypi.org/simple ","date":"2021-04-20","objectID":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["conda","python"],"title":"Conda常用命令","uri":"/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]