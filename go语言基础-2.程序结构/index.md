# Go语言基础—2.程序结构


## 2.1 命名

命名规则：

- 字母和下划线开头，后可以接任何数量的字母、数字或下划线（区分大小写）。

- 不能使用go关键字来命名。
  
  ![20211205-1218-1SIOZY](https://cdn.jsdelivr.net/gh/ZevaXu/picupload@master/uPic/20211205-1218-1SIOZY.png)

- 不推荐使用go预定义名字命名。
  
  ![20211205-1219-VBrR0X](https://cdn.jsdelivr.net/gh/ZevaXu/picupload@master/uPic/20211205-1219-VBrR0X.png)

- 习惯用驼峰命名法。

可见性：

- 在函数内定义，仅函数可用。

- 在函数外定义，包级可用。

- 循环体的变量仅循环内可用。

- 名字开头的大小写决定了是否是导出型（外部是否可以访问）
  
  `fmt.Printf()`

## 2.2 声明

声明语句定义了程序的各种实体对象以及部分或全部的属性。主要有4种类型的声明语句：

- var：变量

- const：常量

- type：类型

- func：函数

## 2.3 变量

声明变量的一般语法：

```
var 变量名 类型 = 表达式
```

其中，类型和`= 表达式`两者可省略其一。编译器会自动推断变量的类型或者初始值。

各个类型的0值：

- 整型类型0值为0

- 布尔类型为false

- 字符串为""

- 接口或引用类型（slice、map、chan、函数）变量对应nil

- 数组或结构体等聚合类型对应的0值为每个元素或字段对应的0值

包级变量在main函数执行之前完成初始化，局部变量在声明语句被执行到时完成初始化。

```
var i,j,k int
var b,f,s = true,2.3,"foo"
var f,err = os.Open(name)
```

### 2.3.1 简短变量声明

```
变量名 := 表达式
i := 0
i,j := 0,1 //声明+（可能赋值）
i,j = j,i //赋值
```

左边为单个变量：

该变量必须为首次声明，语句即起到声明+初始化的作用。

左边为多个变量：

左边至少要有一个是首次声明的变量，对于该变量—声明+初始化；对于其他变量—仅仅赋值。

```
i := 0
i ++
i,j:= 2,3
j++    
```

### 2.3.2 指针

go中的指针对C语言中指针类型进行了一定的限制，使其变得更加安全。

**指针的值和类型：**

一个指针的值对应着一个变量在内存中的地址。

一个指针的类型对应其值对应的内存地址中存储的元素类型。

```
var x int
addr := &x    
```

那么addr的类型为`*int`，addr被称为“指向int类型的指针”，保存了x变量的内存地址。

**指针运算符：**

`&x`:取地址操作

`*addr`:取值操作

优先级很高，高于自增、自减语句

```
i := 0
i++
t := &i
fmt.Println(i, t)//1 0x140000140a0
fmt.Println(*t)//1
fmt.Println(&*t)//0x140000140a0
fmt.Println(*&*t)//1    
```

指针类型的0值为nil。

指针之间也可以比较，当取值（地址）相同或者全部为nil时，才相等。

```
var x, y int 
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
```

go语言中局部变量的地址也是安全的：

```
var p = f()

func f() *int { 
    v := 1 return &v 
}
```

### 2.3.3 new函数

另一个创建变量的方法是调用用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。

```
p := new(int) // p, *int 类型, 指向匿名的 int 变量 
fmt.Println(*p) // "0" 
*p = 2 // 设置 int 匿名变量的值为 2 
fmt.Println(*p) // "2"
```

### 2.3.4 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。

包一级声明的变量:生命周期和整个程序的运行周期是一致的。

局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。

## 2.4 赋值

### 2.4.1 元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。

```
x, y = y, x

a[i], a[j] = a[j], a[i]
```

### 2.4.2 可赋值性

在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。

目前来说的规则：

赋值要求类型必须完全匹配；

nil可以赋值给任何指针或引用类型的变量。

常量有更加灵活的赋值规则。

## 2.5 类型

变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。

类型声明语句：

```
type 类型名字 底层类型
```

类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用。目前中文汉字作为不能导出的类型。

```
package tempconv

import "fmt"

type Celsius float64 // 摄氏温度 
type Fahrenheit float64 // 华氏温度

const ( 
    AbsoluteZeroC Celsius = -273.15 // 绝对零度 
    FreezingC Celsius = 0 // 结冰点温度 
    BoilingC Celsius = 100 // 沸水温度 )

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

为什么要像上述代码自定义类型：

- 为了语义上的考虑，虽然Celsius，Fahrenheit都是float64类型，但是其语义不同，刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；

- 一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型。

- 命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。

比较运算符==和<也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型 的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：

```
var c Celsius 
var f Fahrenheit 
fmt.Println(c == 0) // "true" 
fmt.Println(f >= 0) // "true" 
fmt.Println(c == f) // compile error: type mismatch 
fmt.Println(c == Celsius(f)) // "true"!
```

## 2.7 作用域

作用域和生命周期：

声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。

一个变量的生命周期是指程序运行时变量存在（声明到被回收）的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。

**作用域：**

- 语法块内部声明的名字是无法被外部语法块访问的。
  
  语法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧对应的语法块那样。
  
  有一个语法块为整个源代码，称为全局语法块；然后是每个包的包语法决；每个for、if和switch语句的语法决；每个 switch或select的分支也有独立的语法决；当然也包括显式书写的语法块（花括弧包含的语句）。

- 内置的类型、函数和常量，比如int、len和true 等是在全局作用域的，因此可以在整个程序中直接使用。

- 包级声明的可以在一个包中的任何源文件中访问。

- 导入的包，只有当前go文件可用。

- 局部作用域仅局部可用。

## 2.8 包的概念

**声明属于哪个包：package语句**

go语言以包来组织代码，包类似其他语言中的库或者模块。每个包中可以包含多个xxx.go文件，这些go文件的命名没有要求。其内部第一行的`packge xxx` 代码规定了该文件归属于哪个包。

```goland
package main

import {    
    "fmt"
    "math/rand"
    "time"

}

var c, python, java bool

func main() {
    var i int
    fmt.Println(i, c, python, java)
    fmt.Println(math.pi)
    rand.Seed(time.Now().UnixNano())
}
```

对于应用程序（可以运行的程序）来说，必须要有一个main包，main包下可以包含若干个go文件，但是必须有且仅有一个go文件中包含一个main函数，作为程序的入口。

对于供其他人使用的模块(库)来说，可以没有main包。

**导入包：import 语句**

一个go文件中，以大写字母开头命名的函数称为可导出的函数，也就是可以给外界显示调用；以小写字母开头命名的函数称为不可导出的函数，外界无法调用。此规则适用于（变量、常量、函数、定义类型和类型别名）。

用`import xxx`导入一个包后，即可使用其中的资源，使用时需要加上包名`xxx.funcA`。

当没有导入需要用到的包或者导入了没有用到的包，go编译器都无法编译通过。

**查找包**

> https://golang.org/pkg

> https://godoc.org/

中可以找到标准库和社区写的包。

